# Chapter 6 고급 프로세스 관리

이 장에서는 리눅스 프로세스 스케줄러와 스케줄링 알고리즘을 알아보고 고급 프로세스 관리 인터페이스에 대해 알아본다.

앞으로 살펴볼 시스템 콜은 다음과 같은 부분들에 영향을 끼친다.

- 프로세스의 스케줄링 동작 방식 조작
- 애플리케이션이나 사용자의 목적에 맞는 스케줄러 동작 방식 설정

## 6.1 프로세스 스케줄링

### 실행 가능한 프로세스

블록되지 않은 프로세스

- 블록된 프로세스는 자고 있거나 커널로부터 입출력을 기다리고 있는 프로세스
- 사용자와의 상호 작용, 파일 읽기 쓰기, 네트워크 이벤트 처리 중인 프로세스

실행 가능한 프로세스가 여러개 있을 때 어떤 프로세스가 언제 실행되고 얼마나 오랫동안 실행할지를 결정하는 것이 스케줄러의 기본 책임이다.

### 선점형, 비선점형

멀티 태스킹 운영체제는 선점형과 비선점형으로 나눌 수 있다.

**선점형 멀티 테스킹**은 특정 프로세스가 언제 실행을 멈추고 다른 프로세스가 실행을 재개할지를 스케줄러가 결정하는 방식이다.

- 다른 프로세스를 위해 실행 중인 프로세스를 멈추는 행위를 선점이라 함
- 리눅스는 선점형 멀티 태스킹을 구현
- 스케줄러가 선점하기 전까지 프로세스에 허락된 실행 시간을 프로세스 타임 슬라이스라고 함

**비선점형 멀티 태스킹**은 프로세스가 스스로 실행을 멈추기 전까지 계속 실행하는 방식이다.

- 프로세스가 자발적으로 실행을 잠시 쉬는 것을 양보(yield)라고 한다.
- 이상적으로는 프로세스가 자주 양보하면 좋겠지만 OS에서 강제할 수 없다.
- 요즘은 대세 아님 ㅠㅠㅠ 흙흙


### 프로세스 스케줄러

**프로세스 스케줄러**는 커널의 서브 시스템이며 프로세서의 시간을 시스템 내의 프로세스에 나눠준다.

- 프로세스 스케줄러는 다음에 실행할 프로세스를 선택하기 위한 커널의 구성 요소
- 단일 프로세서: 여러 프로세스를 번갈아 실행해 멀티 태스킹 수행
- 멀티 프로세서: 어느정도는 실제로 병렬적으로 수행하도록 함

현재 리눅스의 스케줄러는 CFS 스케줄러이다. 

> 자세한 설명은 이후에 나올 예정이다.

## 6.1.1 타임 슬라이스

스케줄러는 각 프로세스에 타임 슬라이스를 할당한다.

- 타임 슬라이스가 넘나 크다면, 프로세스는 다음 실행 시간까지 오래 기다려야 하며, 동시 수행 능력이 떨어지게 된다.
- 반면 넘나 잘게 쪼개면, 잦은 프로세스 전환으로 인해 일시적인 지역성(cache)과 같은 장점을 잃게 된다.

요즘 쓰는 CFS는 타임 슬라이스를 사용하지 않음으로써 이런 고민을 해결해준다.

## 6.1.2 입출력 위주 프로세스와 CPU 위주 프로세스

### CPU 위주 프로세스

사용 가능한 타임 슬라이스를 끊임 없이 계속 사용하는 프로세스를 뜻한다.

- CPU 시간에 굶주려 있으며, 스케줄러가 주는 시간을 다 쓴다.
- 과학 계산, 수학연산, 이미지 처리 등등

```cpp
while(1);
```

### 입출력 위주 프로세스

실행 시간보다 리소스를 사용하기 위해 기다리는 데 시간을 더 많이 사용하는 프로세스를 뜻한다.

- 파일이나 네트워크 입출력을 기다리거나
- 사용자 입력을 기다린다.
- 뭐.. cp, mv나 GUI 앱이 있겠지요

### 그래서

두 가지 타입의 프로세스는 최적의 이득을 볼 수 있는 스케줄러의 유형이 다르다.

- 그리고 섞여 있기까지 해서 최적을 알아내는건 핵 어렵다 ㅠㅠㅠ 

## 6.1.3 선점형 스케줄링

전통적인 유닉스 프로세스 스케줄링은 아래와 같이 동작한다.

1. 모든 실행 가능한 프로세스는 타임 슬라이스를 할당 받는다.
2. 주어진 타임 슬라이스를 다 소진하면 
  - 커널은 그 프로세스를 잠시 멈추고 다른 프로세스를 실행한다.
  - 실행 가능한 다른 프로세스가 없다면 커널은 타임 슬라이스를 보충해주고 실행을 재개한다.

이런 동작을 통해 모든 프로세스는 자기보다 우선순위가 높은 프로세스가 있을지라도 실행될 기회를 얻는다.

## 6.2 CFS 스케줄러

CFS가 나오기 전에는 우선순위와 타임 슬라이스를 사용해서 스케줄링을 구현했다.

- 전통적인 스케줄러에서는 CPU 시간인 타임 슬라이스가 프로세스별로 할당된다.
- 또한 프로세스별로 우선순위가 매겨진다.
- 스케줄러는 우선순위가 높은 프로세스를 먼저 실행한다.
- 이 알고리즘은 매우 단순하고 초창기 유닉스 시스템에서는 잘 동작했다.
- 하지만... 최신 데스크톱과 모바일이 높은 응답 성능과 공정성을 요구하면서 부족한 면이..

CFS 스케줄러는 타임 슬라이스를 사용하지 않는다.

- 타임 슬라이스 대신 CPU 시간의 일부를 각 프로세스에 할당한다.
- N개의 프로세스에 대해 각각 1/N 만큼의 CPU 시간을 할당한다.
- 각 프로세스의 nice 값에 따라 가중치를 준다.
  - nice 값을 기본값인 0으로 사용하는 프로세스의 가중치는 1이며 할당받는 CPU 시간에는 변화가 없다.
  - 기본값보다 적은 nice 값을 사용하는, 즉 우선순위가 높은 프로세스는 가중치가 좀 더 높다.
  - 반대의 경우에는 가중치가 낮아 더 적은 CPU 시간을 사용한다.

여기서 프로세스 개수 N으로 나누는 한정된 시간을 타깃 레이턴시(Target Latency) 라고 한다.

```
타깃 레이턴시: 20ms

우선순위가 같은 2개의 프로세스가 실행 가능하다면
20ms / 2
각각 10ms초 동안 실행된다.
```

![http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/102/10267/10267f1.jpg](http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/102/10267/10267f1.jpg)

CFS 스케줄러는 최소단위(minimum granularity)를 사용하여 프로세스에 최소한의 시간은 보장한다.

- 동시에 들어오는 실행 가능한 프로세스가 너무 많으면 각 프로세스에 할당되는 시간이 너무 짧아져 콘텍스트 스위칭에 비용이 과도하게 발생
- 보통은 최소 단위가 적용되지는 않는다.

여튼 이 CFS는 고정된 타임 슬라이스가 아니라 CPU 시간을 할당하기 때문에 공정성을 강제할 수 있게 된다.

- 각 프로세스는 공평하게 CPU를 공유한다.

또한 기존의 스케줄러를 괴롭히던 `CPU 위주 프로세스 + 입출력 위주 프로세스` 를 함께 스케줄링할 때 생기는 문제를 해결해준당.

구우우우우우우욷인듯

## 6.3 프로세서 양보하기

리눅스는 선점형 멀티태스킹 운영체제지만 프로세스가 명시적으로 실행을 양보할 수 있다.

```cpp
#include <sched.h>

// 성공하면 0, 실패하면 -1을 반환한다.
// 근데 거의 실패할 일이 없다고 보면 된다. 하하하하
if (sched_yield ())
    perror("sched_yield");
```

*sched_yield()* 를 호출하면 현재 실행 중인 프로세스를 잠시 멈춘다.

- 결과적으로 스케줄러가 다음에 실행할 새로운 프로세스를 선택하도록 한다.
- 뭐.. 커널이 새로운 프로세스를 수행하기 위해서 현재 실행 중인 프로세스를 선점한 것과 비슷하다.

만약 다른 실행 가능한 다른 프로세스가 없다면 호출 이후 즉시 실행이 재개된다.

> 일반적으로는 이러한 불확실성과 더 나은 대안이 있을 거라는 믿음 때문에 잘 안쓰이는 시스템 콜이다.

## 6.3.1 적당한 사용법

위에서 언급한 것 처럼 sched_yield()를 잘 사용하지는 않는다.

- 리눅스 커널이 더 효율적이고 최적의 스케줄링 결정을 내린다.
- 일개 어플리케이션이 양보하고 말고 할 그런게 아니라고 한다.
- 그래서 OS가 선점형 멀티 태스킹을 선택하는 것

그렇지만 POSIX에서 이런 시스템 콜을 지원하는 이유는 외부 이벤트를 기다려야만 하는 애플리케이션에서 사용되면 좋기 때문이다.

- 한 프로세스가 다른 프로세스를 기다려야 한다면 다른 프로세스 작업이 끝날 때까지 양보한다는 식으로..

```cpp
// Consumer
do {
    while (producer_not_ready()){
        sched_yield();
    }
    process_data();
} while(!time_to_quit());
```

> 위는 예시일 뿐이다.. 실제 Producer/Consumer 패턴에서는 저런거 안씀
> 
> 파이프 같은 블록이 가능한 메커니즘을 사용하면 데이터가 준비될 때까지 블록되겠지요
>
> 이런게 이벤트 드리븐 해법임 ㅎㅎ

스레드 락에서도 *sched_yield()*가 필요했는데.. 이제는 NPTL(Native POSIX, Threading Library)에서 사용자 영역 락을 지원하기 위해 퓨텍스를 사용한 해법을 도입해서 노필요

글구... 또... 양보를 잘하는 착한 프로세스가 되기 위해 필요하긴 한데.. 뒤에 나올 nice로 커버된다.


## 6.4 프로세스 우선순위

> 이 장 내용은 일반적인 비 실시간 프로세스에 적용된다. 실시간 프로세스는 뒤에 나온다.

리눅스는 스케줄링을 할 때 할당된 우선순위를 참고하여 시간을 할당한다.

- CPU 시간은 nice라는 가중치를 적용하여 계산된다.
- nice는 친절하게 대한다라는 의미이며, 쉽게 말해 높을 수록 시간을 쪼끔 받는다.
- 해깔린다

nice 값은 -20~19까지 쓸 수 있고 기본값은 0이다.

- nice 가 클수록 프로세스의 우선순위는 낮아지고 타임 슬라이스가 작아진다.
- nice 가 작을수록 프로세스의 우선순위는 높아지고 타임 슬라이스가 커진다. 

## 6.4.1 nice()

프로세스의 nice 값을 조회하고 설정할 수 있는 *nice()* 시스템 콜을 제공한다.

- 호출이 성공하면 *inc* 만큼 프로세스의 nice 값이 증가하고 새롭게 갱신된 값을 반환한다.
- *CAP_SYS_NICE* 기능이 있는 프로세스만 inc에 음수를 넣을 수 있다.
  - 이 기능이 있는 건 사실상 root가 소유한 프로세스
  - 우선순위가 올라감
- 에러가 발생하면 -1을 반환한다.
  - nice가 결과적으로 -1이 되었을 경우에는 같은 반환이 일어나므로 errno을 통해 재차 확인하자.

```cpp
#include <unistd.h>

int nice(int inc);

errno = 0;
// nice 값을 10만큼 증가
int ret = nice(10);

if(ret == -1 && errno != 0)
    perror("nice");
else
    printf("nice value is now %d\n", ret);
```

이 함수는 현재 nice 값을 얻기 위해서도 쓸 수 있다.

```cpp
printf("nice value is currently %d\n", nice(0));
```

또.. 상대값으로 nice를 바꾸기 싫을 경우는 이렇게도 가능하다.

```cpp
// 현재 nice 값을 얻어온다
int val = nice(0);

// nice 값을 10으로 설정하고 싶다면
val = 10 - val;
errno = 0;
int ret = nice(val);
if(ret == -1 && errno != 0)
    perror("nice");
else
    printf("nice value is now %d\n", ret);
```

## 6.4.2 getpriority()와 setpriority()

우선순위 설정을 위해 nice()보다 *getpriority()*와 *setpriority()* 시스템 콜이 더 선호된다.

- 제어를 더 많이 할 수 있지만 더 복잡함

```cpp
#include <sys/time.h>
#include <sys/resource.h>

int getpriority (int which, int who);
int setpriority (int which, int who, int prio);
```

두 시스템 콜은 `which`와 `who` 인자로 지정한 프로세스, 프로세스 그룹 혹은 사용자를 대상으로 동작한다.

`which` 인자의 값에 따라 `who` 의 의미는 아래처럼 사용된다.

- *PRIO_PROCESS* : 프로세스 ID
- *PRIO_PGRP* : 프로세스 그룹 ID
- *PRIO_USER* : 사용자 ID

만약 `who`가 0이면 현재 프로세스 ID, 프로세스 그룹 ID, 사용자 ID로 해석된다.

### getpriority()

지정한 프로세스 중에서 가장 높은 우선순위(가장 낮은 nice 값)을 반환한다.

- 실패시 -1 반환
- nice()와 동일한 이유로 errno을 추가로 검사해야 한다.

```cpp
// 현재 프로세스의 우선순위 반환
int ret = getpriority(PRIO_PROCESS, 0);
pritnf("nice value is %d\n", ret);
```

### setpriority()

지정한 모든 프로세스의 우선순위를 prio 값으로 지정한다.

- nice()와 마찬가지로 *CAP_SYS_NICE* 기능을 사용할 수 있는 프로세스만 우선순위를 높힐 수 있다.
- 또한 이 기능을 사용할 수 있어야 사용자가 소유하지 않은 프로세스의 우선순위를 조작할 수 있다.
- 실패시 -1, 성공시 0을 반환

```cpp
// 현재 프로세스 그룹 내 모든 프로세스의 우선순위를 10으로 설정
int ret = setpriority(PRIO_PGRP, 0, 10);
if (ret == -1)
    perror("setpriority");
```

## 6.4.3 입출력 우선순위

스케줄링 우선순위 이외에도 리눅스는 프로세스가 입출력 우선순위를 지정할 수 있도록 허용한다.

- 이 값은 프로세스의 입출력 요청의 상대적인 우선순위에 영향을 끼침
- 높은 우선순위를 가지는 프로세스의 입출력 요청을 먼저 처리한다.

기본적으로 입출력 스케줄러도 입출력 우선순위를 결정하기 위해 프로세스의 nice 값을 사용한다.

- 즉 nice 값을 설정하며녀 자동적으로 입출력 우선순위도 변경된다.

여튼 별도로 설정하는 다른 변수에 대한 시스템 콜도 제공한다.

```cpp
// 근데 glibc는 사용자 영역 인터페이스로 제공 안함
// 즉 시스템 콜은 있지만 glibc가 씹음
// 그냥 쓰지마!!!!!!!!!!
int ioprio_get(int which, int who);
int ioprio_set(int which, int who, int ioprio);
```

## 6.5 프로세서 친화

리눅스는 단일 시스템 내에서 멀티 프로세서를 지원한다.

- 부팅 과정을 제외하고 멀티 프로세스를 지원하는 대부분의 작업은 프로세스 스케줄러에서 이루어짐
- 멀티 프로세서를 사용하는 시스템의 프로세스 스케줄러는 반드시 어떤 CPU에서 실행될지를 결정해야 함

여기에는 두 가지 도전 과제가 있다.

1. 시스템의 모든 프로세서를 활용해야 한다.
  - 한 CPU가 놀고 있는데 어떤 프로세스가 실행 대기 중이라면 비효율 적이다.
2. 어떤 프로세스가 한 CPU에 스케줄되면 프로세스는 앞으로도 같은 CPU에서 실행되어야 한다.
  - CPU 이전 비용으로 손실이 발생하기 때문(주로 캐시)
  - 최신 SMP(Symetric Multiprocessing) 시스템의 설계에서는 CPU별로 캐시가 따로 있음

![https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/SMP_-_Symmetric_Multiprocessor_System.svg/1200px-SMP_-_Symmetric_Multiprocessor_System.svg.png](https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/SMP_-_Symmetric_Multiprocessor_System.svg/1200px-SMP_-_Symmetric_Multiprocessor_System.svg.png)

이 두가지 목표는 잠재적으로 충돌을 일으킨다.

만일 한 CPU가 다른 CPU보다 상대적으로 많은 프로세스 부하가 발생한다면, 몇개는 이전 비용을 지불하고 옮길 필요가 있다.

이런 불균형을 개선하기 위해 언제 프로세스를 옮길지를 결정하는 작업을 **로드 밸런싱** 이라고 하며 SMP 머신의 성능에서 매우 중요한 역할을 한다.

### 프로세서 친화도(Processor affinity)

**프로세서 친화도** 는 프로세스를 꾸준히 같은 CPU에 스케줄링할 가능성을 나타낸다.

- **느슨한 친화도**는 프로세스를 같은 CPU에 계쏙 스케줄링하려는 스케줄러의 경향을 의미
- **엄격한 친화도**는 어떤 프로세스를 특정 CPU에 연결하기를 강제하도록 하는 것을 의미(요게 설정가능한 부분 ㅇㅈ?)
- 기본적으로 프로세스는 부모 프로세스의 CPU 친화도를 상속받는다.

## 6.5.1 sched_getaffinity()와 sched_setaffinity()

리눅스는 프로세스의 엄격한 친화도를 조회하고 설정하는 시스템 콜을 제공한다.

```cpp
#define _GNU_SOURCE

#include <sched.h>

typedef struct cpu_set_t;

size_t CPU_SETSIZE:

void CPU_SET (unsigned long cpu, cpu_set_t *set);
void CPU_CLR (unsigned long cpu, cpu_set_t *set);
int CPU_ISSET (unsigned long cpu, cpu_set_t *set);
void CPU_ZERO (cpu_set_t *set);
int sched_setaffinity (pid_t pid, size_t setsize, const cpu_set_t *set);
int sched_getaffinity (pid_t pid, size_t setsize, cpu_set_t *set);
```

### sched_getaffinity()

```cpp
int sched_getaffinity (pid_t pid, size_t setsize, cpu_set_t *set);
```

프로세스 pid의 CPU 친화도를 조회하여 이 값을 *cpu_set_t* 타입 변수에 저장한다.

- pid가 0일 경우 현재 프로세스의 친화도를 조회한다.
- setsize 인자는 *cpu_set_t* 타입의 크기를 나타낸다.
  - 호환성을 유지하기 위해 쓰이는 매개변수
- set 변수에 CPU 친화도가 담긴다

호출이 성공하면 0, 실패하면 -1을 반환한다.

```cpp
cpu_set_t set;

// 호출 전에 CPU_ZERO로 모든 비트를 0으로 채운다.
CPU_ZERO(&set);
int ret = sched_getaffinity(0, sizeof (cpu_set_t), &set);
if (ret == -1){
    perror ("sched_getaffinity");
}

// 0부터 CPU_SETSIZE 까지 순회
// 이 값은 set으로 표현 가능한 프로세서의 개수
// 단일 비트로 표현하기 때문에 sizeof(cpu_set_t) 보다 훨씬 크다.
for(int i = 0; i < CPU_SETSIZE; i++){
    // 이 명령어로 i번째 CPU가 이 프로세스와 연결된 상태인지 검사
    int cpu = CPU_ISSET(i, &set);
    printf("cpu=%i is %s\n", i, cpu ? "set" : "unset");
}
```

실제 프로세서가 2개 장착된 시스템의 경우 아래처럼 출력될 것이다.

- CPU_SETSIZE는 1024이고
- 프로세스가 2개뿐

```
cpu=0 is set
cpu=1 is set
cpu=2 is unset
cpu=3 is unset
...
cpu=1023 is unset
```

여기서 프로세스를 #0에서만 실행시키고 싶고 #1에서는 실행되지 않길 바랄 경우에는 아래처럼 작성한다.

```cpp
cpu_set_t set;

// 모든 비트를 0으로 채움
CPU_ZERO(&set);
// CPU #0은 허용
CPU_SET(0, &set);
// CPU #1은 허용하지 않음
CPU_CLR(1, &set);
int ret = sched_setaffinity(0, sizeof(cpu_set_t), &set);
if(ret == 0)
    perror("sched_setaffinity");

for(int i = 0; i < CPU_SETSIZE; i++){
    int cpu = CPU_ISSET(i, &set);
    printf("cpu=%i is %s\n", i, cpu ? "set" : "unset");
}
```

```
cpu=0 is set
cpu=1 is unset
cpu=2 is unset
cpu=3 is unset
...
cpu=1023 is unset
```

## 6.6 실시간 시스템
## 6.6.1 실시간 시스템의 종류
## 6.6.2 레이턴시, 지터, 최소 응답시간
## 6.6.3 리눅스의 실시간 지원
## 6.6.4 리눅스 스케줄링 정책과 우선순위
## 6.6.4 리눅스 스케줄링 정책과 우선순위 - FIFO 정책
## 6.6.4 리눅스 스케줄링 정책과 우선순위 - 라운드 로빈 스케줄링 정책
## 6.6.4 리눅스 스케줄링 정책과 우선순위 - 표준 스케줄링 정책
## 6.6.4 리눅스 스케줄링 정책과 우선순위 - 리눅스 스케줄링 정책 설정하기
## 6.6.5 스케줄링 인자 설정하기
## 6.6.6 sched_rr_get_interval()
## 6.6.7 실시간 프로세스의 주의점
## 6.6.8 결정론
## 6.6.8 결정론 - 선행 폴트 데이터와 메모리 락
## 6.6.8 결정론 - CPU 친화도와 실시간 프로세스
## 6.7 리소스 제한
## 6.7.1 제한
## 6.7.2 제한 설정과 조회


## 