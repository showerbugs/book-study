# Chapter 6 고급 프로세스 관리

이 장에서는 리눅스 프로세스 스케줄러와 스케줄링 알고리즘을 알아보고 고급 프로세스 관리 인터페이스에 대해 알아본다.

앞으로 살펴볼 시스템 콜은 다음과 같은 부분들에 영향을 끼친다.

- 프로세스의 스케줄링 동작 방식 조작
- 애플리케이션이나 사용자의 목적에 맞는 스케줄러 동작 방식 설정

## 6.1 프로세스 스케줄링

### 실행 가능한 프로세스

블록되지 않은 프로세스

- 블록된 프로세스는 자고 있거나 커널로부터 입출력을 기다리고 있는 프로세스
- 사용자와의 상호 작용, 파일 읽기 쓰기, 네트워크 이벤트 처리 중인 프로세스

실행 가능한 프로세스가 여러개 있을 때 어떤 프로세스가 언제 실행되고 얼마나 오랫동안 실행할지를 결정하는 것이 스케줄러의 기본 책임이다.

### 선점형, 비선점형

멀티 태스킹 운영체제는 선점형과 비선점형으로 나눌 수 있다.

**선점형 멀티 테스킹**은 특정 프로세스가 언제 실행을 멈추고 다른 프로세스가 실행을 재개할지를 스케줄러가 결정하는 방식이다.

- 다른 프로세스를 위해 실행 중인 프로세스를 멈추는 행위를 선점이라 함
- 리눅스는 선점형 멀티 태스킹을 구현
- 스케줄러가 선점하기 전까지 프로세스에 허락된 실행 시간을 프로세스 타임 슬라이스라고 함

**비선점형 멀티 태스킹**은 프로세스가 스스로 실행을 멈추기 전까지 계속 실행하는 방식이다.

- 프로세스가 자발적으로 실행을 잠시 쉬는 것을 양보(yield)라고 한다.
- 이상적으로는 프로세스가 자주 양보하면 좋겠지만 OS에서 강제할 수 없다.
- 요즘은 대세 아님 ㅠㅠㅠ 흙흙


### 프로세스 스케줄러

**프로세스 스케줄러**는 커널의 서브 시스템이며 프로세서의 시간을 시스템 내의 프로세스에 나눠준다.

- 프로세스 스케줄러는 다음에 실행할 프로세스를 선택하기 위한 커널의 구성 요소
- 단일 프로세서: 여러 프로세스를 번갈아 실행해 멀티 태스킹 수행
- 멀티 프로세서: 어느정도는 실제로 병렬적으로 수행하도록 함

현재 리눅스의 스케줄러는 CFS 스케줄러이다. 

> 자세한 설명은 이후에 나올 예정이다.

## 6.1.1 타임 슬라이스

스케줄러는 각 프로세스에 타임 슬라이스를 할당한다.

- 타임 슬라이스가 넘나 크다면, 프로세스는 다음 실행 시간까지 오래 기다려야 하며, 동시 수행 능력이 떨어지게 된다.
- 반면 넘나 잘게 쪼개면, 잦은 프로세스 전환으로 인해 일시적인 지역성(cache)과 같은 장점을 잃게 된다.

요즘 쓰는 CFS는 타임 슬라이스를 사용하지 않음으로써 이런 고민을 해결해준다.

## 6.1.2 입출력 위주 프로세스와 CPU 위주 프로세스

### CPU 위주 프로세스

사용 가능한 타임 슬라이스를 끊임 없이 계속 사용하는 프로세스를 뜻한다.

- CPU 시간에 굶주려 있으며, 스케줄러가 주는 시간을 다 쓴다.
- 과학 계산, 수학연산, 이미지 처리 등등

```cpp
while(1);
```

### 입출력 위주 프로세스

실행 시간보다 리소스를 사용하기 위해 기다리는 데 시간을 더 많이 사용하는 프로세스를 뜻한다.

- 파일이나 네트워크 입출력을 기다리거나
- 사용자 입력을 기다린다.
- 뭐.. cp, mv나 GUI 앱이 있겠지요

### 그래서

두 가지 타입의 프로세스는 최적의 이득을 볼 수 있는 스케줄러의 유형이 다르다.

- 그리고 섞여 있기까지 해서 최적을 알아내는건 핵 어렵다 ㅠㅠㅠ 

## 6.1.3 선점형 스케줄링

전통적인 유닉스 프로세스 스케줄링은 아래와 같이 동작한다.

1. 모든 실행 가능한 프로세스는 타임 슬라이스를 할당 받는다.
2. 주어진 타임 슬라이스를 다 소진하면 
  - 커널은 그 프로세스를 잠시 멈추고 다른 프로세스를 실행한다.
  - 실행 가능한 다른 프로세스가 없다면 커널은 타임 슬라이스를 보충해주고 실행을 재개한다.

이런 동작을 통해 모든 프로세스는 자기보다 우선순위가 높은 프로세스가 있을지라도 실행될 기회를 얻는다.

## 6.2 CFS 스케줄러

CFS가 나오기 전에는 우선순위와 타임 슬라이스를 사용해서 스케줄링을 구현했다.

- 전통적인 스케줄러에서는 CPU 시간인 타임 슬라이스가 프로세스별로 할당된다.
- 또한 프로세스별로 우선순위가 매겨진다.
- 스케줄러는 우선순위가 높은 프로세스를 먼저 실행한다.
- 이 알고리즘은 매우 단순하고 초창기 유닉스 시스템에서는 잘 동작했다.
- 하지만... 최신 데스크톱과 모바일이 높은 응답 성능과 공정성을 요구하면서 부족한 면이..

CFS 스케줄러는 타임 슬라이스를 사용하지 않는다.

- 타임 슬라이스 대신 CPU 시간의 일부를 각 프로세스에 할당한다.
- N개의 프로세스에 대해 각각 1/N 만큼의 CPU 시간을 할당한다.
- 각 프로세스의 nice 값에 따라 가중치를 준다.
  - nice 값을 기본값인 0으로 사용하는 프로세스의 가중치는 1이며 할당받는 CPU 시간에는 변화가 없다.
  - 기본값보다 적은 nice 값을 사용하는, 즉 우선순위가 높은 프로세스는 가중치가 좀 더 높다.
  - 반대의 경우에는 가중치가 낮아 더 적은 CPU 시간을 사용한다.

여기서 프로세스 개수 N으로 나누는 한정된 시간을 타깃 레이턴시(Target Latency) 라고 한다.

```
타깃 레이턴시: 20ms

우선순위가 같은 2개의 프로세스가 실행 가능하다면
20ms / 2
각각 10ms초 동안 실행된다.
```

CFS 스케줄러는 최소단위(minimum granularity)를 사용하여 프로세스에 최소한의 시간은 보장한다.

- 동시에 들어오는 실행 가능한 프로세스가 너무 많으면 각 프로세스에 할당되는 시간이 너무 짧아져 콘텍스트 스위칭에 비용이 과도하게 발생
- 보통은 최소 단위가 적용되지는 않는다.

여튼 이 CFS는 고정된 타임 슬라이스가 아니라 CPU 시간을 할당하기 때문에 공정성을 강제할 수 있게 된다.

- 각 프로세스는 공평하게 CPU를 공유한다.

또한 기존의 스케줄러를 괴롭히던 `CPU 위주 프로세스 + 입출력 위주 프로세스` 를 함께 스케줄링할 때 생기는 문제를 해결해준당.

구우우우우우우욷인듯



## 6.3 프로세서 양보하기
## 6.3.1 적당한 사용법
## 6.4 프로세스 우선순위
## 6.4.1 nice()
## 6.4.2 getpriority()와 setpriority()
## 6.4.3 입출력 우선순위
## 6.5 프로세서 친화
## 6.5.1 sched_getaffinity()와 sched_setaffinity()
## 6.6 실시간 시스템
## 6.6.1 실시간 시스템의 종류
## 6.6.2 레이턴시, 지터, 최소 응답시간
## 6.6.3 리눅스의 실시간 지원
## 6.6.4 리눅스 스케줄링 정책과 우선순위
## 6.6.4 리눅스 스케줄링 정책과 우선순위 - FIFO 정책
## 6.6.4 리눅스 스케줄링 정책과 우선순위 - 라운드 로빈 스케줄링 정책
## 6.6.4 리눅스 스케줄링 정책과 우선순위 - 표준 스케줄링 정책
## 6.6.4 리눅스 스케줄링 정책과 우선순위 - 리눅스 스케줄링 정책 설정하기
## 6.6.5 스케줄링 인자 설정하기
## 6.6.6 sched_rr_get_interval()
## 6.6.7 실시간 프로세스의 주의점
## 6.6.8 결정론
## 6.6.8 결정론 - 선행 폴트 데이터와 메모리 락
## 6.6.8 결정론 - CPU 친화도와 실시간 프로세스
## 6.7 리소스 제한
## 6.7.1 제한
## 6.7.2 제한 설정과 조회


## 