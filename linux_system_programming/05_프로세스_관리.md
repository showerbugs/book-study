# Chapter 5. 프로세스 관리

이 장에서는 프로세스의 생성부터 종료까지 알아본다.

유닉스에서는 fork()와 exec()을 나눔으로써 각 작업을 발전시키고 실험하는 것에 상당한 양의 자유를 주었다.

> 다른 OS는 프로세스 생성시에 시스템 콜을 하나만 사용한다.


## 5.1 프로그램, 프로세스, 스레드

시스템 콜에 대해서 본격적으로 알아보기에 앞서서 프로세스 그 자체에 대해서 먼저 알아보도록 하자.

![http://www.rtos.be/wp-content/uploads/2013/06/process_and_thread.png](http://www.rtos.be/wp-content/uploads/2013/06/process_and_thread.png)

*바이너리* 는 디스크 저장장치에 기록되어 있는 컴파일된, **실행할 수 있는 코드**를 말한다.

- 바이너리는 흔히 프로그램을 지칭하기도, 애플리케이션을 뜻하기도 한다.
- */bin/ls*, */usr/bin/X111*

*프로세스* 는 실행 중인 프로그램이다.

- 프로세스는 메모리에 적재된 바이너리 이미지와 가상화된 메모리의 인스턴스, 
- 열린 파일 같은 커널 리소스, 관련된 사용자 정보와 같은 보안 정보, 
- 하나 이상의 스레드를 포함한다.

*스레드* 는 프로세스 내 실행 단위이다.

- 각각의 스레드는 가상화된 프로세서를 가지고 있다
- 스택, 레지스터, 명령어 포인터 같은 프로세서 상태가 포함된다

*싱글 스레드 프로세스* 는 프로세스가 곧 스레드가 된다.

- 가상화된 메모리 인스턴스 하나
- 가상 프로세스 하나

*멀티 스레드 프로세스* 에는 당연히 스레드가 여러 개 존재한다.

- 프로세스와 관련된 가상 메모리는 모든 스레드가 같은 주소 공간을 공유

![https://www.tutorialspoint.com/operating_system/images/thread_processes.jpg](https://www.tutorialspoint.com/operating_system/images/thread_processes.jpg)

## 5.2 프로세스 ID

모든 프로세스는 프로세스 ID(pid) 라고 하는 유일한 식별자로 구분된다.
- pid는 특정 시점에서 유일한 값임을 보장한다.

*동작 중인 다른 프로세스가 없을 때 커널이 실행*하는 **idle 프로세스** 는 pid가 0이다

- 한마디로 아무 프로세스도 동작하고 있지 않을 때 실행하는 프로세스
- 리소스를 사용하지 않는다.
    
시스템의 *부팅이 끝나면 커널이 실행하는 최초 프로세스* 인 **init 프로세스**의 pid는 1이다

- 리눅스에서 init 프로세스는 init 프로그램이다
- 커널이 실행하는 최초 프로세스와 그 프로세스를 위한 프로그램을 init이라 지칭한다.
- 사용자가 커널에 어떤 프로세스를 실행하라고 명시작으로 요청하지 않을 경우 커널은 아래 순서로 init 프로세스를 확인한다.
    1. */sbin/init*
    2. */etc/init*
    3. */bin/init*
    4. */bin/sh* 
    5. 못찾으면 커널 패닉

init 프로세스는 커널로부터 제어권을 넘겨받은 후에 부팅 과정을 계속 진행한다

- 시스템 초기화, 다양한 서비스 구동, login 프로그램 실행 등등

![https://notes.shichao.io/apue/figure_9.2.png](https://notes.shichao.io/apue/figure_9.2.png)

## 5.2.1 프로세스 ID 할당

보통 커널의 최대 pid 값은 *32768* 이다

- signed 16비트 정수를 사용했던 유닉스 시스템과의 호환성을 위해(2^15)
- */proc/sys/kernel/pid_max* 를 수정하여 최대 값을 바꿀 수는 있다.

커널은 pid를 순서대로 엄격하게 할당한다.

1. 현재 할당된 pid 값이 17이라면 다음에 실행되는 프로세스의 pid는 18이 된다.
2. *pid_max* 에 도달하면 처음부터 다시 할당 한다.

리눅스는 오랫동안 유일한 pid를 보장하지는 않지만 짧은 기간동안 안정적이고 유일한 pid를 제공한다.

## 5.2.2 프로세스 계층

새로운 프로세스를 생성하는 프로세스를 **부모 프로세스**라고 하고, 새롭게 생성된 프로세스를 **자식 프로세스**라고 한다.

init 프로세스를 제외한 모든 프로세스는 다른 프로세스로부터 생성된다.

- 그래서 모든 자식 프로세스에는 부모 프로세스가 있다.
- 부모 프로세스 ID(ppid)로 부모 프로세스를 알 수 있다.

모든 프로세스는 사용자와 그룹이 소유하고 있다.

- 소유(ownership)이란 리소스에 대한 접근 권한을 제어하기 위해 사용된다,
- 사용자는 */etc/passwd* 파일에, 그룹은 */etc/group* 파일에 정의되어 있다.
- 모든 자식 프로세스는 부모 프로세스의 사용자와 그룹 권한을 상속받는다.

모든 프로세스는 다른 프로세스와의 관계를 표현하고 있는 프로세스 그룹의 일부이다.

- 이는 위에서 나오는 사용자/그룹 개념과는 구분된다.
- 자식 프로세스는 보통 부모 프로세스의 프로세스 그룹에 속하게 된다.
- 셸에서 파이프를 사용하면(*ls | less* 같이) 모든 명령어는 같은 프로세스 그룹에 속한다.
- 프로세스 그룹을 통해 파이프라인에 속한 프로세스, 또 그들의 모든 자식 프로세스에 시그널을 보내거나 정보를 얻기 쉬워진다.
- 사용자 관점에서 프로세스 그룹은 실제 일과 밀접한 관계가 있다.

![http://images.slideplayer.com/26/8877367/slides/slide_25.jpg](http://images.slideplayer.com/26/8877367/slides/slide_25.jpg)



## 5.2.3 pid_t

프로그램에서 pid는 *pid_t* 자료형으로 표현되며 이는 <sys/types.h>에 정의되어 있다.

- 리눅스에서는 pid_t는 보통 C의 int의 typedef이다.

## 5.2.4 프로세스 ID와 부모 프로세스 ID 얻기

```cpp
#include <sys/types.h>
#include <unistd.h>

// 호출한 프로세스의 pid를 반환
pid_t getpid (void);

// 호출한 프로세스의 부모 프로세스의 pid를 반환
pid_t getppid (void);

printf("My pid=%jd\n", (intmax_t) getpid());
printf("Parent's pid=%jd\n", (intmax_t) getppid());
```

intmax_t 자료형을 반환했는데 이는 시스템에서 지원하는 어떤 Signed 정수라도 호환성 있게 저장할 수 있도록 해준다.


## 5.3 새로운 프로세스 실행하기

유닉스에서 프로그램 이미지를 메모리에 적재하고 실행하는 과정과 새로운 프로세스를 생성하는 부분이 분리되어 있다.

exec류 시스템 콜에서는:

1. 프로그램 바이너리를 메모리에 적재
2. 프로세스의 주소 공간에 있는 이전 내용을 대체
3. 새로운 프로그램의 실행을 시작

fork 시스템 콜에서는:

1. 부모 프로세스를 거의 그대로 복제하여 프로세스를 생성

새로운 프로세스에서 새로운 프로그램을 실행하려면 이 두가지 과정을 진행한다.

1. 새로운 프로세스를 포크하고(fork())
2. 생성된 프로세스에 새로운 바이너리를 적재하여 실행한다(exec류 함수)

![http://www.bogotobogo.com/Linux/images/process/exec_ls.png](http://www.bogotobogo.com/Linux/images/process/exec_ls.png)

## 5.3.1 exec 함수들

exec류 시스템 콜은 여러 형태로 제공된다.

- 리눅스에서는 execve()만 시스템 콜이고 나머지는 wrapper 함수이다.

함수 이름에 있는 각각의 character는 아래의 의미를 갖는다.

- l : arg를 list로 제공
- v : arg를 vector로 제공
- p : file 인자 값을 사용자의 실행 경로 환경 변수에서 찾게 됨
    - */home/abc/workspace/project_a/bin/run_program* -> *run_program* 
    - 이 경우 전체 실행 경로가 아니라 단순히 파일 이름만 명시해도 사용자의 실행 경로 환경
    - 변수에서 그 파일을 찾을 수만 있다면 사용이 가능
    - 실행될 프로그램을 PATH 조작 등을 통해 변경할 수 있어 보안에 취약함
- e : 새롭게 생성될 프로세스를 위한 새로운 환경 변수를 제공


```cpp
#include <unistd.h>

int execl(const char *path,
    const char *arg,
    ...);

int execlp (const char *file, 
    const char *arg, ...);

int execle (const char *path, 
    const char *arg, 
    ..., 
    char * const envp[]);

int execv (const char *path,
    char *const argv[]);
   
int execvp (const char *filename,
    char *const argv[]);
    
int execve (const char *filename,
    char *const argv[],
    char *const envp[]);
```

```cpp
// 유닉스의 관례에 따라 첫 번째 인자로 프로그램 이름인 vi를 전달했다.
int ret = execl("/bin/vi", "vi", "/home/kidd/hooks.txt", NULL);
// 호출이 성공한다면 새로운 프로그램의 시작점으로 건너 뛰어가므로
// 여기로 넘어오지 않고 이 코드는 프로세스의 주소 공간에 더이상 존재하지 않는다.
if (ret == -1)
    perror("execl");
```

execl() 호출이 성공하면 아래와 같은 변화가 생긴다.

1. 프로세스의 주소 공간과 프로세스 이미지가 변경된다.
2. 대기 중인 시그널은 사라진다
3. 프로세스가 받은 시그널은 디폴트 방식으로 처리된다(핸들러가 사라지기 때문)
4. 메모리 락이 해제
5. 스레드의 속성 대부분이 기본값으로 돌아간다
6. 프로세스의 통계 대부분이 재설정
7. 메모리에 맵핑된 파일을 포함하여 그 프로세스의 메모리 주소 공간과 관련된 모든 내용이 사라진다.
8. 사용자 영역에만 존재하는 모든 내용이 사라짐
    - atexit()과 같은 내용들도 포함하여

하지만 아래 것들은 변화하지 않는다.

1. pid, ppid
2. 우선순위
3. 소유자와 그룹

일반적으로 열린 파일(open을 통해)은 exec 호출 과정에서 그대로 상속된다.

- 새롭게 실행되는 프로그램이 fd만 알고 있으면 접근이 가능하다는 것을 의미
- 하지만 바람직하지 않기 때문에 exec 전에 파일을 모두 close한다.

```cpp
int ret;

ret = execvp ("vi", "vi", "/home/kidd/hooks.txt", NULL);
if (ret == -1) // ERROR

const char *args[] = { "vi", "/home/kidd/hooks.txt", NULL };
ret = execv ("/bin/vi", args);
if (ret == -1) // ERROR
```


## 5.3.2 fork() 시스템 콜

## 5.4 프로세스 종료하기

## 5.4.1 프로세스를 종료하는 다른 방법

## 5.4.2 atexit()

## 5.4.3 on_exit()

## 5.4.4 SIGCHILD

## 5.5 자식 프로세스 종료 기다리기

## 5.5.1 특정 프로세스 기다리기

## 5.5.2 좀 더 다양한 방법으로 기다리기

## 5.5.3 BSD 방식으로 기다리기: wait3()과 wait4()

## 5.5.4 새로운 프로세스를 띄운 다음에 기다리기

## 5.5.5 좀비 프로세스

## 5.6 사용자와 그룹

## 5.6.1 실제, 유효, 저장된 사용자 ID와 그룹 ID

## 5.6.2 실제, 저장된 사용자, 그룹 ID 변경하기

## 5.6.3 유효 사용자 ID나 유효 그룹 ID 변경하기

## 5.6.4 BSD 방식으로 사용자, 그룹 ID 변경하기

## 5.6.5 HP-UX 방식으로 사용자, 그룹 ID 변경하기

## 5.6.6 바람직한 사용자/그룹 ID 조작법

## 5.6.7 저장된 사용자 ID 지원

## 5.6.8 사용자 ID와 그룹 ID 얻어오기