# Chapter 9 메모리 관리

## Overview

메모리는 프로세스에서 사용할 수 있는 리소스 중에서 가장 기본적이면서 핵심적인 리소스이다

이 장에서는 메모리 할당과 조작, 해제에 대해 알아본다

## 9.1 프로세스 주소 공간

리눅스는 물리적인 리소스인 메모리를 가상화한다.

- 커널이 개별 프로세스에 독자적인 가상 주소 공간을 제공한다.
- 이 가상 주소 공간은 0부터 시작해서 늘어난다.

![9_memory_0](9_memory_0.jpg)

## 9.1.1 페이지와 페이징

페이지는 메모리 관리 유닛(`MMU`)에서 관리할 수 있는 **최소 단위**이며 메모리 관리 측면에서 가장 중요한 단위이다.

- 페이지 -> 워드 -> 바이트 -> 비트 로 구성된다.
- 32비트 시스템
  - 페이지 크기: 4KB
  - 최대 페이지 개수: 100만개
- 64비트 시스템 
  - 페이지 크기: 8KB
  - 최대 페이지 개수: 수십억개

![9_memory_1](9_memory_1.png)

페이지에는 유효한 페이지와 유효하지 못한 페이지가 있다.

- 유효한 페이지: 실제 페이지(RAM 또는 Swap 파티션이나 디스크에 저장된 파일과 같은 2차 저장장치)에 연관되는 경우
- 유효하지 못한 페이지: 실제 물리 메모리와 연관되지 않은, 사용되지 않는 주소 -> 접근하면 세그멘테이션 폴트

2차 저장장치와 연결된 유효한 페이지인 경우에는 실제 메모리에 올리기 전에는 프로세스에서 접근할 수 없다.

- 프로세스에서 접근하려고 하면/ MMU는 페이지 폴트를 발생시킨다
- 그러면 커널은 2차 저장장치에 있는 데이터를 RAM으로 페이징한다
  - 공간이 부족할 경우 RAM은 우선순위가 낮은 데이터를 페이징 아웃한다.

![9_memory_2](9_memory_2.gif)

## 공유와 copy-on-write

여러 프로세스는 동일한 물리 메모리를 서로의 다른 가상 메모리에서 공유할 수 있다.

- 표준 C 라이브러리를 사용할 때 각자의 가상 주소 공간으로 매핑하지만 실제 메모리에는 1개만 올라와 있다.
- 두 프로세스가 하나의 큰 데이터베이스를 맵핑하는 경우도 마찬가지

![9_memory_3](9_memory_3.png)

공유 데이터에 수정이 가해지는 경우에는 데이터를 복사하고 가상 메모리의 매핑을 복사한 데이터를 향하게 한다.

1. 쓰기 요청이 발생하고 MMU가 예외 발생
2. 커널이 쓰기를 요청한 프로세스를 위해 그 페이지의 복사본을 새로 만듦
3. 프로세스는 새로 만들어진 페이지에 쓰기 요청을 진행

![9_memory_4](9_memory_4.gif)

이런 방식을 `copy-on-write(COW)`라고 한다.(COW는 페이지 단위로 발생한다.)

## 9.1.2 메모리 영역

커널은 접근 권한과 같은 특정 속성을 공유하는 **맵핑, 메모리 영역**에 페이지를 배열한다.

1. **텍스트 세그먼트**
    - 프로세스의 프로그램 코드, 문자열 상수, 상수 변수, 읽기 전용 데이터로 구성
    - 읽기 전용이며 실행 파일이나 라이브러리 오브젝트 파일에서 직접 맵핑
2. **스택 영역**
    - 프로세스의 실행 스택으로 구성
    - 스택 깊이가 깊어지고 얕아짐에 따라 동적으로 크기가 바뀐다. 
    - 실행 스택에는 지역 변수와 함수의 반환 데이터로 구성된다.
    - 멀티스레드 프로세스에서는 스레드 당 하나의 스택이 존재
3. **힙**
    - 프로세스의 동적 메모리로 구성
    - 쓰기 및 크기 변경이 가능
    - malloc은 이 영역에 메모리를 할당
4. **bss 세그먼트**
    - 초기화되지 않은 전역 변수를 담는다
    - 이 변수들은 C 표준에 따라(기본적으로는 0) 특수한 값을 담는다


![9_memory_5.jpg](9_memory_5.jpg)

리눅스에서는 두 단계로 변수를 최적화한다.

1. 초기화하지 않은 데이터는 bss 세그먼트에 할당된다.
    - 그러면 링커(ld)는 오브젝트 파일에 특수 값을 저장하지 않을 수 있어 바이너리의 크기가 줄어든다.
2. 이 세그먼트가 메모리에 적재되면 커널은 이 세그먼트를 copy-on-write 기법을 통해 0으로 채워진 페이지에 맵핑
    - 변수에 기본값인 0이 들어가게 된다.(효율적)


## 9.2 동적 메모리 할당하기

메모리 관리 시스템의 기본은 동적 메모리의 할당/사용/해제 이다.

- 동적 메모리는 컴파일 시점이 아니라 실행 중에 할당되며 크기를 미리 알 수 없다.
- e.g., 파일 크기를 알 수 없고, 사용자가 얼마나 많은 키를 입력할지도 모르기에 다양한 버퍼가 필요할 수 있기 때문

> 자동 변수나 정적 변수의 형태로 쓰이기는 하지만 이는 변동이 적다.

**malloc()** 은 동적 메모리를 얻는 대표적인 인터페이스이다.

```cpp
#include <stdlib.h>

// size 바이트만큼 메모리를 할당해서 새롭게 할당된 메모리 영역의
// 시작점을 가리키는 포인터를 반환.
// 이 메모리의 내용은 정의되지 않은 상태이다(0이라는 보장도 없다)
// 호출이 실패하면 NULL을 반환한다.
void * malloc(size_t size);
```

```cpp
// c에서는 별도로 casting하지 않아도 변환된다.
// 명시하지 않는 것이 c에서는 Good Pattern
char *p = malloc(2048);
struct treasure_map *map = malloc(sizeof (struct treasure_map));

if (!p)
    perror ("malloc");

// 하지만 cpp에서는 타입변환을 명시적으로 해주어야 한다.
char *p = (char*) malloc(2048);
```

관례적으로 malloc을 부르고 실패시 프로그램을 종료하는 함수를 정의하곤 한다.

```cpp
void * xmalloc (size_t size) {
    void *p;
    p = malloc (size);
    if (!p) {
        perror ("xmalloc");
        exit (EXIT_FAILURE);
    }
    return p;
}
```

## 9.2.1 배열 할당하기

배열에 들어가는 항목의 크기는 고정되어 있지만 배열의 길이가 고정되지 않은 경우에 활용할 수 있는 **calloc()** 함수를 제공한다.

- 할당된 메모리의 내용을 초기화하지 않는 malloc과 달리 calloc은 메모리 영역을 0으로 채워준다.
- `malloc(nr * size) + 0으로 초기화 == calloc(nr, size)` 

```cpp
#include <stdlib.h>

// 각각 크기가 size 바이트인 원소를 nr개 담을 수 있는 메로리 블록에 대한 포인트 반환
void * calloc(size_t nr, size_t size);
```

만약 malloc을 0으로 초기화하도록 사용하고 싶다면 아래처럼 구현해서 쓰면 된다.

```cpp
void * malloc0 (size_t size) {
    return calloc(1, size);
}

void * xmalloc0 (size_t size) {
    void *p;
    p = calloc(1, size);
    if (!p) {
        perror("xmalloc0");
        exit (EXIT_FAILURE);
    }
    return p;
}
```

## 9.2.2 할당 크기 변경

C 언어는 이미 할당된 영역을 키우거나 줄일 수 있는 변경 인터페이스를 제공한다.

```cpp
#include <stdlib.h>

// ptr이 가리키는 메모리 영역을 size 바이트로 새로 조정한다.
// 새로운 크기의 메모리를 반환하며 이전과 동일한 ptr이 아닐 수도 있다.
// 기존 메모리를 확장할 수 있다면 확장하고
// 그럴수 없다면 새로운 영역으로 복사한 다음 이전 영역을 해제한다.
void * realloc (void *ptr, size_t size);
```

복사할 상황이 있기 때문에 realloc은 상대적으로 비용이 많이 든다.

- `realloc(ptr, 0) == free(ptr)`
- `realloc(NULL, 4) == malloc(4)`

메모리 영역을 줄이는 예제를 살펴보자.

```cpp
// map 2개를 할당 받고
struct map *p = calloc(2, sizeof (struct map));
// 1개로 줄인다.
struct map *r = realloc(p, sizeof (struct map));
free(r)
```

## 9.2.3 동적 메모리 해제

동적 할당은 수동으로 해제될 때까지 프로세스 주소 공간에 계속 남아 있다. 따라서 프로그래머는 동적으로 할당된 메모리를 시스템에 반환해야 할 의무가 있다.

> 스택을 거슬러 올라오면서 자동으로 거둬들이는 자동 할당과 다르다.

```cpp
#include <stdlib.h>

// ptr이 가리키는 메모리를 해제한다.
// ptr은 malloc, calloc, realloc이 반환한 값이여야 한다.
// 중간값이면 시스템 그래시 발생
void free (void *ptr);
```

free(NULL)은 조용히 반환되기 때문에 아래 조건문은 불필요하다.

```cpp
if (ptr != NULL) free(ptr);
```

간단한 예제를 보자. 이 예제는 `print_chars(5, 'X')` 이면 아래 문구를 출력한다.

```
X
XX
XXX
XXXX
XXXXX
```

```cpp
void print_chars (int n, char c)
{
    int i;
    for(i = 0; i < n; i++) {
        char *s;
        int j;
        // i+2 크기의 char 배열을 할당하고 0으로 초기화
        s = calloc(i + 2, 1);
        for (j = 0; j < i + 1; j++){
            s[j] = c;
        }
        printf("%s\n", s);

        // 메모리 반환
        free(s)
    }
}
```

만약 free를 하지 않는다면 포인터 s도 잃어버려 접근도 하지 못하게 된다. 이런 경우를 메모리 릭이라 한다.

또, 메모리를 해제한 이후에 접근하는 경우가 있을 수 있는데, 시스템 에러가 발생하게 된다.

## 9.2.4 정렬

메모리 정렬은 메모리에 데이터를 나열하는 방식을 의미한다. 

- 메모리 주소 A가 n바이트에 정렬되었다고 할 때, n은 2의 거듭제곱이고, A는 n의 배수이다.

변수가 자신의 크기의 배수가 되는 메모리 주소에 저장되면 이를 자연스럽게 정렬된 상태라고 한다.

- 4 바이트 크기의 변수는 4의 배수인 메모리 주소에 위치할 경우 자연스럽게 정렬된 상태이다.
- 즉 주소 값의 최하위 두 비트가 0인 경우이다.
- 따라서 크기가 2^n 바이트인 타입은 주소에서 최하위 n비트가 0이 되어야 한다.

![9_buddysystem.jpg](9_buddysystem.jpg)

## 정렬된 메모리 할당하기

POSIX는 malloc, calloc, realloc에서 반환된 메모리가 어떤 표준 C 타입을 사용하든지 적절히 정렬되어야 한다고 정의한다.

- 32비트 시스템에서는 항상 8바이트로 정렬
- 64비트 시스템에서는 16바이트로 정렬

프로그래머가 페이지 같은 큰 단위로 정렬된 동적 메모리가 필요할 경우에 `posix_memalign()`이라는 함수를 사용하면 된다.

- 직접 블록 입출력이나 소프트웨어와 하드웨어 간의 통신을 위한 버퍼를 적절히 정렬해야 하는 경우
- 즉 malloc이 제공하는 정렬 단위보다 더 큰 정렬이 필요한 경우 사용

```cpp
#define _XOPEN_SOURCE 600
#define _GNU_SOURCE

#include <stdlib.h>

// 동적 메모리를 size 바이트만큼 할당하고 alignment의 배수인 메모리 주소에 맞게 정렬
// alignment는 2의 거듭제곱이며, void 포인터 크기의 배수여야 한다.
// 할당된 메모리 주소는 memptr에 저장된다.
int posix_memalign(void **memptr, size_t alignment, size_t size);
```

```cpp
char *buf;

// 256바이트에 맞춰 정렬되는 1KB를 할당
int ret = posix_memalign(&buf, 256, 1024);

// 사용하고

free(buf);
```

## 다른 정렬 고려 사항

비표준이나 복잡한 타입에는 표준 타입보다 더 복잡한 요구사항이 존재한다.


1. 구조체의 정렬 요구사항은 가장 큰 멤버의 타입을 따른다.
    - 가장 큰 타입이 32비트 정수이고 4바이트 단위로 정렬된다면
    - 이 구조체 역시 4바이트 단위로 정렬된다.
2. Union의 정렬 요구사항도 가장 큰 타입을 따른다.
3. 구조체는 각 멤버가 그 타입의 요사항에 맞게 정렬될 수 있도록 패딩을 넣는다
    - ![9_padding.png](9_padding.png)
    - 구조체 멤버를 오름차순으로 조정하면 패딩에 소모되는 공간이 최소화될 수 있다.
4. 배열의 정렬 요구사항은 기본 타입을 따른다.

## 9.3 데이터 세그먼트 관리하기

> 크게 중요해보지 않음

유닉스 시스템은 전통적으로 데이터 세그먼트를 직접 관리할 수 있는 인터페이스를 제공한다.

- 일반적으로는 malloc이 더 편하고 강력해서 안쓴다.
- 힙 기반 할당 메커니즘을 너무나도 구현하고 싶다면 참고

```cpp
#include <unistd.h>

// end로 breakpoint 이동
int brk (void *end);
// breakpoint를 increment만큼 이동하고 주소를 반환
int * sbrk (intptr_t increment);

printf("The current break point is %p\n", sbrk(0));
```

![9_brk](9_brk.jpg)

## 9.4 익명 메모리 맵핑

리눅스에서는 일반적으로 [buddy 메모리 할당 기법](https://ko.wikipedia.org/wiki/%EB%B2%84%EB%94%94_%EB%A9%94%EB%AA%A8%EB%A6%AC_%ED%95%A0%EB%8B%B9)을 사용한다.

이 기법은 빠르고 정렬을 잘해주는 장점이 있지만 파편화(내부/외부)가 발생하기 쉽다는 단점이 있다.

- 내부 파편화는 요청에 필요한 것보다 많이 반환해야 해 발생
- 외부 파편화는 요청을 충족시킬만한 메모리가 나눠져 있어 사용할 수 없을 경우 발생

또한 큰 라이브러리 3개를 할당받았을 때, 힙에 저장하면

A - B - C로 처음에 할당받았을때 B가 해제되도 heap을 해제할 수 없다는 문제도 있다.

이러한 문제를 해결하기 위해 큰 메모리 할당에서는 `익명 메모리 맵핑`을 사용해 메모리 할당 요청에 대응한다.

- 연관되어 있는 파일이 없기 때문에 익명이라 한다
- 익명 메모리 맵핑은 0으로 채워진 메모리 블록이다.
- 익명 메모리 맵핑은 힙 영역 밖에 위치하기 때문에 파편화를 일으키지 않는다.

익명 메모리 맵핑의 장점은 다음과 같다.

1. 파편화를 신경쓰지 않아도 된다. 
    - 필요로 하지 않을 때 맵핑을 해제하여 시스템으로 반환할 수 있다.
2. 크기 조정이 가능하고 권한 설정이 가능하며 일반 맵핑과 마찬가지로 힌트를 사용할 수 있다.
3. 개별 메모리 할당이 독립된 메모리 맵핑에 존재한다. 전역 힙을 관리할 필요가 없다.

반면 익명 메모리 맵핑은 힙에 비해 두 가지 단점이 있다.

1. 메모리 맵핑의 크기는 시스템 페이지 크기의 정수배가 된다.
    - 페이지 크기의 정수배로 떨어지지 않는 할당 요청은 공간을 낭비한다.
    - 할당 크기가 작은 경우 상대적으로 더 많은 공간을 낭비한다.
2. 새로운 메모리 맵핑을 생성하는 데 드는 부하가 더 많이 걸린다.
   - 이 역시 할당 크기가 작을수록 부하가 늘어난다.
   - 힙에서는 메모리를 할당받을 때 커널의 개입이 전혀 없때

그래서 glibc에서 제공하는 malloc()은 데이터 세그먼트를 활용해서 작은 할당을 처리하고 익명 메모리 맵핑은 대규모 할당에 이용한다.

- 임계값은 조정이 가능하며 현재는 128KB이다.
- 임계값 이하로 메모리를 할당하면 힙을 사용
- 그보다 큰 할당은 익명 메모리 맵핑을 사용한다..

![9_memory_5.jpg](9_memory_5.jpg)
   

## 9.4.1 익명 메모리 맵핑 생성하기

4장에서는 `mmap()` 시스템 콜을 사용해 수동으로 메모리 맵핑을 만들고 `munmap()` 시스템 콜을 통해 메모리 맵핑을 해제할 수 있었다.

```cpp
void * mmap (
    void *start, size_t length,
    int prot, int flags, int fd, off_t offset);

int munmap (void *start, size_t length);
```

익명 메모리 맵핑은 파일을 열고 관리할 필요가 없기 때문에 생성하기 더 쉽다.

```cpp
void *p;

// start가 NULL이면 시스템이 할당 위치를 정하고 반환해준다.
// 보통 NULL로 지정
// prot는 읽기 쓰기로 한다. 그렇지 않으면 의미가 없다.
// flags를 익명으로 지정하고 private 비트를 설정해 공유하지 않는다.
// ANONYMOUS인 경우 fd와 offset은 무시되지만
// 이식성을 고려해 -1, 0을 넣어준다.

p = mmap(NULL,   // 위치는 신경쓰지 않는다
    512 * 1024,  // 512KB
    PROT_READ | PROT_WRITE,  // 읽기/쓰기
    MAP_ANONYMOUS | MAP_PRIVATE, // 익명, 공유하지 않음
    -1, 0);

if (p == MAP_FAILED)
    perror("mmap");
else
    // p는 512kb의 익명 메모리를 가리킨다.

// 사용이 끝난 512KB 맵핑을 반환한다.
int ret = munmap(p, 512 * 1024);
```

익명 맵핑으로 할당했을 때 얻을 수 있는 장점은

- 0으로 채워져있고, COW가 적용되어 있다는 것이다.
- memset을 할 필요가 없다.
- 그 외에는 위에서 서술한 장점을 참고


## 9.4.2 /dev/zero 맵핑하기

BSD 에서 사용하는 방법이라고 하는데 잘 안쓴다고함

## 9.5 고급 메모리 할당

이 장에서 살펴본 메모리 할당 연산은 glibc나 프로그래머가 변경할 수 있는 커널 인자로 제약하거나 제어할 수 있다.

이런 커널 인자 제어에는 `mallopt()` 가 사용된다.

```cpp
#include <malloc.h>

// param으로 지정한 메모리 관리와 관련된 인자를
// value로 설정한다.
int mallopt(int param, int value);
```

지원하는 param 값은 아래와 같다.

1. M_CHECK_ACTION
    - 다음 절에 나올 MALLOC_CHECK_ 환경 변수 값(미루겠다는건가)
2. M_MMAP_MAX
    - 시스템이 동적 메모리 요청을 위해 생성할 수 있는 최대 맵핑 개수
    - 이 한계에 도달하면 데이터 세그먼트를 사용해 할당을 처리한다.
    - 이 값이 0이면 익명 맵핑을 사용하지 않는다.
3. M_MMAP_THRESHOLD
    - 익명 맵핑으로 처리할 할당 요청의 임계값(바이트)
    - 임계값을 초과하는 경우 익명 맵핑을 사용한다.
    - 이 값이 0이면 항상 익명 맵핑을 사용하게 된다.
4. M_MXFAST
    - Fast bin의 최대 크기(0일 경우 쓰지 않음)
    - 힙에 존재하는 특수한 메모리 영역으로 인접한 메모리 블록과 합쳐지지 않고 반환되지도 않는다.
    - 파편화 문제가 있지만 할당 속도가 빠르다는 장점이 있다.
5. M_PERTURB
    - 메모리 관리 에러를 탐지하는 데 도움이 되는 메모리 포이즈닝을 활성화한다.
6. M_TOP_PAD
    - 데이터 세그먼트 크기를 조정할 때 사용되는 패딩의 크기
    - brk로 크기를 키울 때 여분을 두어 호출 수를 줄인다.
7. M_TRIM_THRESHOLD
    - glibc가 sbrk()를 호출해서 메모리를 커널에 반환하기 전에 데이터 세그먼트의 빈 메모리의 최소 크기
    - 이 값이 작을 수록 자주 호출된다.

```cpp
// 64KB를 넘기는 메모리 할당은 mmap()을 사용한다.
int ret = mallopt(M_MMAP_THRESHOLD, 64 * 1024);
```

## 9.5.1 malloc_usable_size()와 malloc_trim()으로 튜닝하기

리눅스는 메모리 할당 시스템을 저수준에서 제어할 수 있는 두 함수를 제공한다.

첫 번째 함수는 주어진 할당 메모리 영역에서 사용 가능한 바이트를 얻어오는 기능을 제공한다.

```cpp
#include <malloc.h>

// ptr이 가리키는 메모리 영역의 실제 할당 크기를 반환
// 버퍼를 주었을 수도 있기 때문에 요청했던 크기보다 클 수는 있다.
size_t malloc_usable_size (void *ptr);
```

```cpp
size_t len = 21;
size_t size;
char * buf;

buf = malloc(len);
size = malloc_usable_size(buf);

// 실제로는 buf에서 size 바이트만큼 사용할 수 있다.
```

두 번째 함수는 프로그램이 glibc에 즉시 해제할 수 있는 모든 메모리를 커널로 강제 반환하도록 한다.

```cpp
#include <malloc.h>

// 유지되야 하는 padding 바이트를 제외한, 
// 가능한 많은 데이터 세그먼트를 줄인다.
int malloc_trim(size_t padding);
```

이 두 함수 모두 쓸일이 없다...

## 9.6 메모리 할당 디버깅

위의 옵션 중 `MALLOC_CHECK_` 을 설정하면 메모리 서브시스템의 고급 디버깅 기능을 활성화할 수 있다.

- 디버깅 기능을 활성화하면 성능적으로 효율적이지 않지만 디버깅 단계에서만 활용한다면 큰 가치가 있다.

환경 변수로 디버깅을 제어하므로 컴파일을 다시할 필요가 없다.

```sh
# 간단하게 아래처럼 실행하면 된다. 
$ MALLOC_CHECK_=1 ./rudder
```

1. `MALLOC_CHECK_ == 0`
    - 에러를 무시한다.
2. `MALLOC_CHECK_ == 1`
    - 유익한 정보를 담은 메시지가 strerr로 출력
2. `MALLOC_CHECK_ == 2`
    - 에러 발생시 abort()를 호출해 종료
    
## 9.6.1 통계 수집하기

메모리 할당 시스템과 관련된 통계를 수집하기 위한 mallinfo() 함수를 제공한다.

```cpp
#include <malloc.h>

// mallinfo 구조체에 통계를 담아 반환한다.
struct mallinfo mallinfo (void);

struct mallinfo {
    int arena; // malloc이 사용하는 데이터 세그먼트의 크기
    int ordblks; // 비어 있는 메모리 블록 수
    int smblks; // 패스트 빈 수
    int hblks; // 익명 맵핑 수
    int gblkhd; // 익명 맵핑 크기
    int usmblks; // 전체 할당 최대 크기
    int fsmblks; // 사용 가능한 패스트 빈의 크기
    int uordblks; // 전체 할당 공간의 크기
    int fordblks; // 사용 가능한 메모리 블록의 크기
    int keepcost; // 정리가 가능한 공간 크기
}
```

사용법은 간단한다

```cpp
struct mallinfo m;
m = mallinfo();
printf("free chunks: %d\n", m.ordblks);
```

리눅스에서는 메모리 관련 통계를 strerr로 출력하는 malloc_stats() 함수를 제공한다.

```cpp
#include <malloc.h>
void malloc_stats(void);
```

```
Arena 0:
system bytes     =  865939456
in use bytes     =  851988200
Total (incl. mmap):
system bytes     = 3216519168
in use bytes     = 3202567912
max mmap regions =      65536
max mmap bytes   = 2350579712
```