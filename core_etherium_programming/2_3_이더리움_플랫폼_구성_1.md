# 2.3 이더리움 플랫폼 구성

## 2.3.1 데이터 계층

## Account

이더리움 플랫폼에서 Account는 모든 Transaction의 실행 주체이자 기본 단위로서 모든 것은 Account에서 시작한다.

![2_1.jpg](2_1.jpg)

### EOA, Externally Owned Account

- 책에서는 Account라고 부른다.
- 일반적으로 말하는 Etherium 사용자 Account가 EOA
- Smart Contract 실행 코드를 가지고 있지 않다.
- 사람이 직접 private key로 관리
    - 분실 시 해당 Account도 분실한 것이 됨
- EOA는 private key를 사용하여 전자 서명된 Transaction을 생성하고 실행
    - 이를 통해 다른 EOA에 이더를 전송하거나
    - Contract Account에 메시지를 보내 해당 코드를 실행

### CA, Contract Account

- 책에서는 Contract 또는 Smart Contract라고 부른다.
- Smart Contract의 정식 용어
- EOA나 다른 CA의 메시지를 받아 내부의 Smart Contract 코드를 실행한다.
    - 이후, 코드 내에서 내부 저장 공간에 데이터를 저장하거나
    - 새로운 Contract를 생성한다.

## Account(Cont.)

Account는 다음과 같은 형태이 20바이트의 주소를 갖는다.

```
0xp89daa0987da987s09a7sdf098s70f9a87sdf8as7f
```

### Account 주소

```go
// 패키지: accounts, 파일명: accounts.go
type Account struct {
    Address common.Address  `json:"address"`
    // URL은 해당 주소의 위치를 나타내며 옵션 사항이다.
    URL     URL             `json:"url"`
}

// 패키지: Common, 파일명: Types.go
const AddressLength = 20   // 이더리움 Address는 20 byte 주소임
type Address [AddressLength]byte
```

### Account 정보

```go
// 패키지: core/state, 파일명; state_object.go
type Account struct {
    // 해당 Account로부터 보내진 Transaction 수를 의미(0으로 시작)
    // Transaction이 무제한 실행될 때는 의미가 없으나 
    // 오직 한 번만 실행되게 할 때 사용할 수 있는 카운터
    // 만약 CA이면 Nounce는 Account에 의해 생성된 Contract 수이다.
    Nonce   uint64
    // 이더 잔고(Wei 기준)
    Balance *bit.Int
    // 해당 Account가 저장될 머클 패트리시아 트리의 루트 노드
    // 이 트리의 루트 노드를 암호 해시한 것이 바로 Root이다.
    // 암호 해시는 Keccak256 암호 해시를 사용
    Root    common.Hash   
    // 해당 Account의 Smart Contract ㅂ이트 코드의 해시를 말함
    // EOA의 경우 코드 해시값이 nil
    CodeHash []byte
}
```

## Account 생성

모든 이더리움 Account는 private key와 public key의 쌍으로 정의된다.

> 개인 키와 공개 키를 asymmetric key라고 한다. 

이더리움은 asymmetric algorithm으로 256비트 ECDSA(타원형 곡선 방식) 을 사용한다.

1. 임의의 private key를 만들어낸다.
2. ECDSA 알고리즘으로 private key로부터 256비트 public key를 생성한다.
3. 암호 해시 알고리즘 Keccak256을 사용하여 public key을 암호화해 32바이트의 고정값을 생성
4. 이 중 20바이트를 절삭해 Account Address로 사용

![2_2.jpg](2_2.jpg)

## Accounts 패키지: Account 생성

`Accounts/keyStore` 패키지는 Account 키의 저장 디렉터리의 관리를 담당한다.

- *NewAccount()* 는 암호화를 하기 위한 키값을 변수 passpharase로 전달받고
- *storeNewKey()* 함수를 호출한다.
- *newKey()* 함수를 호출하여 임의의 문자열로 키를 생성하고 이를 저장한다.

```go
// 패키지: Accounts/KeyStore, 파일명: keystore.go
func (ks *KeyStore) NewAccount(passphrase string) (accounts.Account, error) {
    // (1) storeNewKey() 함수를 호출
    _, account, err := storeNewKey(ks.storage, crand.Reader, passphrase) 
    // ...
}

func storeNewKey(ks KeyStore, rand io.Reader, auth string) (*Key, accounts.Account, error) {
    // (2) 키를 생성한다.
    key, err := newKey(rand)
    if err != nil {
        return nil, accounts.Account{}, err
    }
    a := accounts.Account{
        Address: key.Address,
        URL: accounts.URL{
            Scheme: KeyStoreScheme,
            Path: ks.JoinPath(keyFileName(key.Address)) 
        }
    }
    // (3) 키를 저장한다
    if err := ks.StoreKey(a.URL.Path, key, auth); err != nil {
        zeroKey(key.PrivateKey)
        return nil, a, err
    }
    return key, a, err
}
```



```go
// 패키지: Accounts/KeyStore, 파일명: key.go
func newKey(rand io.Reader) (*Key, error) {
    // (3) 임의의 문자열을 매개변수로 임의의 256비트 private key 생성
    privateKeyECDSA, err := ecdsa.GenerateKey(crypto.S256(), rand)
    if err != nil {
        return nil, err
    }
    // (4) public key 생성
    return newKeyFromECDSA(privateKeyECDSA), nil
}

func newKeyFromECDSA(privateKeyECDSA *ecdsa.PrivateKey) *Key {
    id := uuid.NewRandom()
    // (5) 128비트 UUID를 생성한 후에 UUID와 Address와 
    //     PrivateKey로 구성된 Key 구조체의 포인터 반환
    key := &Key{
        Id:         id,
        Address:    crypto.PubkeyToAddress(privateKeyECDSA.publicKey),
        PrivateKey: privateKeyECDSA,
    }
    return key
}

func PubkeyToAddress(p ecdsa.PublicKey) common.Address {
    pubBytes := FromECDSAPub(&p)
    // (6) Pubkey를 받아 Keccak 암호 해싱한 뒤 ByteToAdress 호출
    return common.BytesToAddress(Keccak256(pubBytes[1:])[12:])
}

type Address [AddressLength]byte

func ByteToAddress(b []byte) Address {
    var a Address
    // (7) SetByte 함수로 Account Address 설정
    a.SetBytes(b)
    return a
}

func (a *Address) SetBytes(b []byte) {
    // ...
    // (8) 뒷부분 20바이트만을 최종 Account로 잘라서 반환
    copy(a[AddressLength-len(b):], b)
}
```

## Account 상태

Account들이 모인 것을 이더리움에서는 상태(state)라고 하고 이를 *stateObject* 구조체로 저장한다.

- *stateObject*를 통해 Account에 접근하여 상태를 변경
- Account 변경 후에 *CommitTrie()* 함수를 호출하여 
- 변경된 Trie를 ethdb 패키지를 통해 LevelDB에 업데이트한다.

```go
// 패키지: core/state, 파일명: state_object.go
type stateObject struct {
    address  common.Address // Address
    addrHash common.Hash    // Account 주소의 Keccak256 Hash
    data     Account        // 이더리움 Account
    db       *StateDB       // 상태를 저장할 DBMS에 대한 포인터

    // 쓰기용 캐시, 상태 값으로 필요한 데이터의 임시 저장 캐시
    trie Trie  // Trie 저장소
    code Code  // Contract의 바이트코드
}
```

## Transaction

이더리움에서 Transaction은 다른 Account나 Contract에 보낼 데이터 구조체로서,  전사 서명으로 암호화한다.

- 하나의 Account에서 다른 Account로 이더를 전송하거나
- Smart Contract의 특정 함수를 호출할 때 Transaction이 사용된다.
- 새로운 Smart Contract를 이더리움 노드에 배포할 때도 사용된다.

Transaction의 발신자는 ECDSA 서명 알고리즘을 사용하여 개인키로 서명해야 한다.

- 해당 Transaction이 정당한 것(자신이 발신한 것)임을 입증하기 위해서

이더리움의 경우 중첩된 바이너리 배열 데이터를 효과적으로 처리하기 위해 RLP라는 자체 인코딩 방식을 사용한다.

> 요건 나중에 설명이 나온다고 함

![2_3.jpg](2_3.jpg)
![2_4.jpg](2_4.jpg)

## core 패키지: Transaction 생성 및 전자 서명

다음은 이더리움에서 사용하는 Transaction의 구조체이다.

```go
// 패키지: core/types, 파일명: transaction.go
type Transaction struct {
    data txdata    
    hash atomic.Value // Transaction 해시값
    Size atomic.Value
    from atomic.Value // 발신자 주소
}

type txdata struct {
    // 발신자에 의해 보내진 트랜잭션의 개수. 0으로 시작
    AccountNonce uint64
    
    // *실제 Transaction의 실행 비용은 `Price * GasLimit`로 계산
    // Transaction의 발신자가 각 실행 단계에서 지급하는 가스 가격
    Price        *big.Int
    // Transaction 수행 시 지급 가능한 최대 범위
    GasLimit     *big.Int

    // 메시지 수신처의 Address
    // nil일 경우 수신자가 Contract임을 의미
    Reciptent    *common.Address
    // 수신자에게 전송할 이더의 양
    Amount       *big.Int
    // 메시지 호출 시 매개변수 등이 전달(option)
    // 배포 시에는 Smart Contract의 초기화 코드도 포함 가능
    Payload      []byte

    // ECDSA 전자 서명을 위한 값들
    V *big.Int
    R *big.Int
    S *big.Int
    
    // ...
}
```

*SignTX()* 함수는 서명자와 서명자의 개인키를 사용하여 서명된 새로운 트랜잭션을 반환한다.

```go
// 패키지: core/types, 파일명: transaction_signing.go
func SignTx(tx *Transaction, s Signer, prv *ecdsa.PrivateKey) (*Transaction, error) {
    h := s.Hash(tx)
    // (1) Hash와 Private Key를 사용해 서명
    sig, err := crypto.Sign(h[:], prv)
    if err != nil {
        return nil, err
    }
    // (2) raw tx를 sig로 signing
    return tx.WithSignature(s, sig)
}

func (tx *Transaction) WithSignature(signer Signer, sig []byte) (*Transaction, error) {
    r, s, v, err := signer.SignatureValues(tx, sig)
    if err != nil {
        return nil, err
    }
    cpy := &Transaction{ data: tx.data }
    // (3) R, S, V 전자 서명값 설정
    cpy.data.R, cpy.data.S, cpy.data.V = r, s, v
    return cpy, nil
}
```

## Receipt

> 우리가 현실 세계에서 물건을 구매하면 영수증을 받듯이 이더리움은 모든 Transaction의 로그를 Receipt에 저장한다.

Recept에는 Transaction과 관련된 실행환경과 검색을 위한 인덱싱 등 블록 내에 정상 등록된 트랜잭션에 대한 정보들이 저장된다.



```go
// 패키지: core/types, 파일명: receipt.go
type Receipt struct {
    // Transaction 처리 후의 상태 정보
    PostState         []byte
    // Transaction 처리 후 실패 여부
    Failed            bool
    // 해당 Transaction과 Receipt를 포함하고 있는 블록에서
    // 사용한 누적 가스 비용
    CumulativeGasUsed *big.Int
    // Logs에 저장된 로그 정보들을 빠르게 검색하는데 사용하기 위한 블룸 필터
    Bloom             Bloom
    // Transaction의 실행 과정에서 생성된 로그들
    Logs              []*Log
    // 해당 Transactiondml 주소
    TxHash            common.Hash
    // Smart Contract의 주소(CA로부터 생성됬을 경우)
    ContractAddress   common.Address
    // 해당 Transaction 실행에 사용된 가스 비용
    GasUsed           *big.Int
}
```

## 블록체인

이더리움에서 Account의 상태 전이를 유발하는 Transaction들과 관련 정보는 블록이라는 구조체에 저장된다.

- 이 블록들은 시간순으로 마치 체인처럼 서로 연결되어 있다.
- 이렇게 연결된 블록들을 Block Chain이라 부른다.
- Block Chain은 네트워크에 연결되어 있는 모든 노드에 전파/공유 된다.
- 결국, 블록체인이 공유 원장이다.

## 블록

이더리움에서 블록은 *블록 해더*, *엉클 블록*, *Transaction*으로 구성된다.

- 또한 마이닝 작업의 난이도 등도 포함

[https://etherscan.io/block/4246458](https://etherscan.io/block/4246458)

이더리움 블록의 데이터 구조체는 다음과 같다.

```go
// 패키지: core/types, 파일명: block.go
type Block struct {
    header        *Header
    uncles        []*Header
    transactions  Transactions
    // ...
    // 난이도 총합(total difficulty)
    td            *big.Int
}

// 블록 해더에 실제 주요 정보 대부분이 저장되어 있다.
// 블록 해더 내의 해시값은 모두 Keccak256 해시 함수의 결과를 말한다.

type BlockNonce [8]byte
type Bloom [32]byte

type Header struct {
    // 부모 블록 헤더
    parentHash   common.Hash 
    // 엉클 블록들의 해시값
    uncleHash    common.Hash 
    // 마이닝 작업 후 이더를 지급받을 Account 주소
    Coinbase     common.Address 
    // Account의 상태 정보가 모여 있는 머클 패트리시아 트리의 루트 노드
    Root         common.Hash
    // Transaction이 모여 있는 머클 패트리시아 트리의 루트 노드
    TxHash       common.Hash
    // Recept들이 모여 있는 머클 패트리시아 트리의 루트 노드
    ReceiptHash  common.Hash
    // 로그 정보들을 검색하는데 사용하는 32바이트 블룸 필터
    Bloom        Bloom
    // 현재 블록의 난이도
    Difficulty   *big.Int
    // 현재 블록의 번호(제네시스 블록은 0번)
    Number       *big.Int
    // 블록당 현재 지급 가능한 최대 가스 총합
    GasLimit     *big.Int
    // 현재 블록 내에 Transaction에 의해 사용된 가스의 총합
    GasUsed      *big.Int
    // 현재 블록의 최초 생성 시간을 기록
    Time         *big.Int
    // 추가 정보
    Extra        []byte
    // Nonce와 MixDigest는 블록 생성을 위한 마이닝 작업시 사용된다.
    MixDigest    common.Hash
    Nonce        BlockNonce
}
```

## 블룸 필터

> [블룸 필터란?](https://namu.wiki/w/%EB%B8%94%EB%A3%B8%20%ED%95%84%ED%84%B0)

이더리움에서는 256비트 블룸 필터를 사용한다.

- 트랜잭션 목록이나 해당 트랜잭션들에서 생성된 로그들이 중복 저장되는 것을 막고 쉽게 찾을 수 있음
- 로그의 필드들을 색인해 필터에 추가

이렇게 하면 로그를 블록 내에 직접 저장하지 않게 되어 저장 공간을 절약할 수 있음

## Genesis Block

Genesis Block은 블록체인에서 첫 번째에 위치한 최초 블록을 말한다.

- 이전 블록이 없음
- 블록 넘버는 0
- 트랜젝션 없음

다음은 제네시스 블록의 구조체이다.

```go
// 패키지: core, 파일명: genesis.go
type Genesis struct {
    Config      *params.ChainConfig // <--
    Nonce       uint64
    Timestamp   uint64
    ExtraData   []byte
    GasLimit    uint64
    Difficulty  *big.Int
    Mixhash     common.Hash
    Coinbase    common.Address
    Alloc       GenesisAlloc // <--
    Number      uint64
    GasUsed     uint64
    ParentHash  common.Hash
}
```

이더리움 클라이언트들은 같은 제네시스 블록을 가지고 있을 때만 서로를 연결하고 블록들을 싱크한다.

- 따라서 제네시스 블록이 다르면 다른 시스템이다.
- 이런 식으로 private network를 구축할 수 있다.

Geth 같은 이더리움 클라이언트는 *genesis.json* 를 사용해 제네시스 블록을 생성한다.

```json
{
    "config": {
        "chainId": 0,
        "homesteadBlock": 0,
        "eip155Block": 0,
        "eip158Block": 0
    },
    "alloc" : {},
    "coinbase" : "0x0000",
    "difficulty" : "0x20000",
    "extraData" :"",
    "gasLimit" : "0xfefd8",
    "nonce": "0x000000042",
    "mixhash": "0x000",
    "parentHash": "0x000",
    "timestamp": "0x00"
}
```

