# 코딩인터뷰 완전 분석 Chapter 10. 정렬과 탐색

## Intro - Problem

Person 객체를 담은 아주 큰 배열이 있을 때 이 배열에 담긴 객체를 나이 순으로 정렬하라

## Intro - Solve

1년단위의 bucket sort나 radix sort가 가장 적합하다

- 각 버킷에 1년
- O(n)

## Bubble sort

- 평균 실행 시간: O(n^2)
- 최악 실행 시간: O(n^2)
- 메모리: O(1)

```java
void bubblesort(int[] array){
    int temp;
    for (int i = 0; i < array.length - 1; i++){
        for (int j = i; j < array.length -1; j++){
            if(array[j] > array[j + 1]){
                temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
}
```

## Selection Sort

- 평균 실행 시간: O(n^2)
- 최악 실행 시간: O(n^2)
- 메모리: O(1)

```java
void selectionsort(int[] array){
    int temp;
    for (int i = 0; i < array.length - 1; i++){
        for (int j = i + 1; j < array.length; j++){
            if(array[i] > array[j]){
                temp = array[j];
                array[j] = array[i];
                array[i] = temp;
            }

        }
    }
}
```

## Merge Sort

- 평균 실행 시간: O(nlog n)
- 최악 실행 시간: O(nlog n)
- 메모리 요구량: 상황에 따라 다름

```java
void mergesort(int[] array){
    mergesort(array, 0, array.length - 1)
}
void mergesort(int[] array, int low, int high){
    if(low < high){
        int middle = (low + high) / 2;
        // 왼쪽 절반을 정렬
        mergesort(array, low, middle); 
        // 오른쪽 절반을 정렬
        mergesort(array, low, middle);
        // 병합
        merge(array, low, middle, high);
    }
}

void merge(int[] array, int low, int middle, int high) {
    int[] helper = new int[array.length];

    /* 두 부분을 helper 배열에 복사 */
    for(int i = low; i <= high; i++){
        helper[i] = array[i];
    }

    int helperLeft = low;
    int helperRight = middle + 1;
    int current = low;

    // helper 배열 순회. 왼쪽 절반과 오른쪽 절반을 비교하여
    // 작은 원소를 추출하여 원래 배열에 복사해 넣는다
    while (helperLeft <= middle && helperRight <= high){
        if (helper[helperLeft] <= helper[helperRight]) {
            array[current] = helper[helperLeft];
            helperLeft++;
        } else { // 오른쪽 원소가 왼쪽 원소보다 작으면
            array[current] = helper[helperRight];
            helperRight++;
        }
        current++;
    }

    // 왼쪽 절반 배열에 남은 원소를 원래 배열에 복사해 넣음
    int remaining = middle - helperLeft;
    for (int i = 0 ; i <= remaining; i++) {
        array[current + i] = helper[helperLeft + i];
    }
    // 오른쪽 절반 배열에 남은 원소는 원래 그 자리에 있을 것이기에 생략한다.
}
```

## Quick Sort


- 평균 실행 시간: O(nlog n)
- 최악 실행 시간: O(n^2)
- 메모리 요구량: O(log n)

```java
void quicksort(int arr[]){
    quicksort(arr, 0, arr.length - 1);
}
void quicksort(int arr[], int left, int right) {

}
```