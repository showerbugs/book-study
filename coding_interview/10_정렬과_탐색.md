# 코딩인터뷰 완전 분석 Chapter 10. 정렬과 탐색

## Intro - Problem

Person 객체를 담은 아주 큰 배열이 있을 때 이 배열에 담긴 객체를 나이 순으로 정렬하라

## Intro - Solve

1년단위의 bucket sort나 radix sort가 가장 적합하다

- 각 버킷에 1년
- O(n)

## Bubble sort

- 평균 실행 시간: O(n^2)
- 최악 실행 시간: O(n^2)
- 메모리: O(1)

```java
void bubblesort(int[] array){
    int temp;
    for (int i = 0; i < array.length - 1; i++){
        for (int j = i; j < array.length -1; j++){
            if(array[j] > array[j + 1]){
                temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
}
```

## Selection Sort

- 평균 실행 시간: O(n^2)
- 최악 실행 시간: O(n^2)
- 메모리: O(1)

```java
void selectionsort(int[] array){
    int temp;
    for (int i = 0; i < array.length - 1; i++){
        for (int j = i + 1; j < array.length; j++){
            if(array[i] > array[j]){
                temp = array[j];
                array[j] = array[i];
                array[i] = temp;
            }

        }
    }
}
```

## Merge Sort

- 평균 실행 시간: O(nlog n)
- 최악 실행 시간: O(nlog n)
- 메모리 요구량: 상황에 따라 다름

```java
void mergesort(int[] array){
    mergesort(array, 0, array.length - 1)
}
void mergesort(int[] array, int low, int high){
    if(low < high){
        int middle = (low + high) / 2;
        // 왼쪽 절반을 정렬
        mergesort(array, low, middle); 
        // 오른쪽 절반을 정렬
        mergesort(array, low, middle);
        // 병합
        merge(array, low, middle, high);
    }
}

void merge(int[] array, int low, int middle, int high) {
    int[] helper = new int[array.length];

    /* 두 부분을 helper 배열에 복사 */
    for(int i = low; i <= high; i++){
        helper[i] = array[i];
    }

    int helperLeft = low;
    int helperRight = middle + 1;
    int current = low;

    // helper 배열 순회. 왼쪽 절반과 오른쪽 절반을 비교하여
    // 작은 원소를 추출하여 원래 배열에 복사해 넣는다
    while (helperLeft <= middle && helperRight <= high){
        if (helper[helperLeft] <= helper[helperRight]) {
            array[current] = helper[helperLeft];
            helperLeft++;
        } else { // 오른쪽 원소가 왼쪽 원소보다 작으면
            array[current] = helper[helperRight];
            helperRight++;
        }
        current++;
    }

    // 왼쪽 절반 배열에 남은 원소를 원래 배열에 복사해 넣음
    int remaining = middle - helperLeft;
    for (int i = 0 ; i <= remaining; i++) {
        array[current + i] = helper[helperLeft + i];
    }
    // 오른쪽 절반 배열에 남은 원소는 원래 그 자리에 있을 것이기에 생략한다.
}
```

## Quick Sort


- 평균 실행 시간: O(nlog n)
- 최악 실행 시간: O(n^2)
- 메모리 요구량: O(log n)

```java
void quicksort(int arr[]){
    quicksort(arr, 0, arr.length - 1);
}
void quicksort(int arr[], int left, int right) {
    int index = partition(arr, left, right);
    if (left < index - 1) { // 왼쪽 파티션 정렬
        quicksort(arr, left, index - 1);
    }
    if (index < right) {
        quicksort(arr, index, right);
    } 
}

int partition(int arr[], int left, int right) {
    // 분할 기준 원소 선정
    int pivot = arr[(left + right) / 2]; 

    while(left <= right) {
        // 왼쪽 파티션 원소 가운데 오른쪽 파티션으로 옮겨야 하는 원소 참색
        while(arr[left] < pivot) left++;
        // 오른쪽 파티션 원소 가운데 왼쪽 파티션으로 옮겨야 하는 원소 참색
        while(arr[right] > pivot) right--;

        // 원소들의 자리를 바꾸고 left와 right를 이동
        if (left <= right) {
            swap (arr, left, right);
            left++;
            right--;
        }
    }
    return left;
}
```

## Radix Sort

- 실행 시간 O(kn)
- k는 자릿수 개수

```java



void radixsort(int arr[]){
    radixsort(arr, arr.length);
}

void radixsort(int arr[], int n)
{
    // Find the maximum number to know number of digits
    int m = getMax(arr, n);

    // Do counting sort for every digit. Note that instead
    // of passing digit number, exp is passed. exp is 10^i
    // where i is current digit number
    for (int exp = 1; m/exp > 0; exp *= 10){
        countSort(arr, n, exp);
    }
}

int getMax(int arr[], int n)
{
    int mx = arr[0];
    for (int i = 1; i < n; i++){
        if (arr[i] > mx)
            mx = arr[i];
    }
    return mx;
}

// A function to do counting sort of arr[] according to
// the digit represented by exp.
void countSort(int arr[], int n, int exp)
{
    int output[] = new int[n]; // output array
    int i;
    int count[] = new int[10];
    Arrays.fill(count,0);

    // Store count of occurrences in count[]
    for (i = 0; i < n; i++){
        count[ (arr[i]/exp)%10 ]++;
    }

    // Change count[i] so that count[i] now contains
    // actual position of this digit in output[]
    for (i = 1; i < 10; i++){
        count[i] += count[i - 1];
    }

    // Build the output array
    for (i = n - 1; i >= 0; i--)
    {
        output[count[ (arr[i]/exp)%10 ] - 1] = arr[i];
        count[ (arr[i]/exp)%10 ]--;
    }

    // Copy the output array to arr[], so that arr[] now
    // contains sorted numbers according to curent digit
    for (i = 0; i < n; i++)
        arr[i] = output[i];
}
```

## 탐색 알고리즘

뭐.. 이진 탐색 정도?

```java
int binarysearch(int[] a, int x){
    int low = 0;
    int high = a.length - 1;
    int mid;

    while(low <= high) {
        mid = (low + high) / 2;
        if (a[mid] < x) {
            low = mid + 1;
        } else if (a[mid] > x) {
            high = mid - 1;
        } else {
            return mid;
        }
    }
    return -1
}

int binarysearchRecursive(int[] a, int x, int low, int high) {
    if (low > high) return -1; // 오류

    int mid = (low + high) / 2;
    if (a[mid] < x) {
        return binarysearchRecursive(a, x, mid + 1, high);
    } else if (a[mid] > x) {
        return binarysearchRecursive(a, x, low, mid - 1);
    } else {
        return mid;
    }
}
```

## 연습문제 10.1

정렬된 배열 A와 B가 주어진다. 

A의 끝에는 B를 수용하기 충분한 여유 공간이 있다. 

B와 A를 정렬된 상태로 병합하는 메서드를 작성하라

## 연습문제 10.2

철자 순서만 바꾼 문자열이 서로 인접하도록 문자열 배열을 정렬하는 메서드를 작성하라.

## 연습문제 10.3

n개의 정수로 구성된 정렬 상태의 배열을 임의 횟수만큼 회전시켜 얻은 배열이 입력으로 주어진다고 하자.

이 배열에서 특정한 원소를 찾는 알고리즘을 고안하라.

회전시키기 이전에, 원래 배열은 오름차순으로 정렬되어 있엇다고 가정한다.

```
- 예
  입력: {15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14} 에서 5를 찾을 것
  출력: 8 (5의 array index)
```

## 연습문제 10.4

줄당 하나의 문자열이 들어 있는 20GB짜리 파일이 있다고 하자.

이 파일을 정렬하려면 어떻게 해야 하겠는지 설명하라

## 연습문제 10.5

빈 문자열이 섞여 있는 정렬 상태의 배열이 주어졌을 때, 특정한 문자열의 위치를 찾는 메서드를 작성하라

```
- 예
  입력: {"at", "", "", "", "ball", "", "", "car", "", "", "dad", "", ""}
       위 배열에서 ball을 찾아라
  출력: 4
```

## 연습문제 10.6

각 행과 각 열이 오름차순으로 정렬된 상태인 M x N 행렬이 주어졌을 때, 특정한 원소를 찾는 메서드를 구현하라

## 연습문제 10.7

한 서커스단이 다른 사람 어깨 위에 다른 사람이 올라서도록 하는 `인간 탑 쌓기` 순서를 고안하고 있다.

- 실질적이고 미학적인 이유로, 어깨 위에 올라서는 사람은 아래 있는 사람보다 키도 작고 더 가벼워야 한다.

해당 순서에 참여하는 단원의 키와 몸무게가 주어졌을 때, 최대로 쌓을 수 있는 탑을 계산하는 메서드를 작성하라

```
- 예:
  입력(키, 몸무게): (65, 100) (70, 150) (56, 90) (75, 190) (60, 95) (68, 110)
  출력: 최대 탑 높이는 6이며, 다음과 같이 구성된다.
       (56, 90) (60, 95) (65, 100) (68, 110) (70, 150) (75, 190)
```

## 연습문제 10.8

정수 스트림을 읽는다고 하자. 주기적으로 어떤 수 x의 랭킹(x보다 같거나 작은 수의 개수)을 확인하고 싶다.

해당 연산을 지원하는 자료구조와 알고리즘을 구현하라.

- track(int x): 수 하나를 읽을 때마다 호출되는 메서드 
- getRankOfNuber(int x): x보다 같거나 작은 수의 개수를 반환하는 메서드 

```
- 예:
  입력 스트림: 5, 1, 4, 4, 5, 9, 7, 13, 3
  getRankOfNumber(1) = 0
  getRankOfNumber(3) = 1
  getRankOfNumber(4) = 3
```