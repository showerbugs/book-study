# Chapter 5 알고리즘의 정당성 증명

## 5.1 알고리즘의 정당성 증명

문제가 복잡해지면 알고리즘이 문제를 제대로 해결하는지 파악하기 어렵기 때문에 수학적인 기법들을 동원해 증명을 하는 것이 좋다.

- 외우는 것보다 증명을 공부하는 것이 좋은 이유는 알고리즘을 유도하는 데 결정적인 통찰을 담고 있기 때문
- 여기서는 정당성 증명에서 흔히 나타나는 패턴들은 다른 알고리즘을 증명하는 데에 이용되므로 잘 이해하길 바람

## 5.2 수학적 귀납법과 반복문 불변식

수학적 귀납법은 반복적인 구조를 갖는 명제들을 증명하는 데 유용하게 사용되는 증명 기법이다.

귀납법 증명은 크게 세 단계로 나누어진다.

1. 단계 나누기
    - 증명하고 싶은 사실을 여러 단계로 나눔
    - 당연하게 생각되지만 중요한 과정
    - e.g., 100개의 도미노를 도미노 하나씩으로 나눈다.
2. 첫 단계 증명
    - 첫 단계에서 증명하고 싶은 내용이 성립함을 보인다.
    - e.g., 첫 번째 도미노는 직접 손으로 밀어서 쓰러뜨린다.
3. 귀납 증명
    - 한 단계에서 증명하고 싶은 내용이 성립한다면, 다음 단계에서도 성립함을 보인다.
    - e.g., 한 도미노가 쓰러지면 다음 도미노 역시 반드시 쓰러진다.

사다리 게임에서 맨 위 선택지와 맨 아래 선택지가 언제나 1:1 대응이 된다는 것을 귀납법으로 증명해보겠습니다.

1. 단계 나누기
    - 텅 빈 N개의 세로줄에서는 항상 맨 위 선택지와 맨 아래 선택지가 1:1 대응이 됩니다.
2. 첫 단계 증명
    - 텅 빈 N개의 세로줄에서는 항상 맨 위 선택지와 맨 아래 선택지가 1:1 대응이 됩니다.
3. 귀납 증명
    - 가로줄을 그어서 두 개의 세로줄을 연결했다고 합시다. 
    - 이 때 두 세로줄의 결과는 서로 뒤바뀝니다.
    - 두 세로줄의 결과가 바뀌어도 1:1 대응은 변하지 않으므로 다음 단계에서도 1:1 속성이 유지됩니다.

![5_1.png](5_1.png)

## 반복문 불변식

귀납법을 이용해 알고리즘의 정당성을 증명할 때는 `반복문 불변식`이라는 개념이 유용하게 쓰입니다.

- 반복문의 내용이 한 번 실행될 때마다 중간 결과가 우리가 원하는 답으로 가는 길 위에 잘 있는지를 명시하는 조건입니다.
- 반복문이 마지막에 정답을 계산하기 위해서는 항상 이 식이 변하지 않고 성립해야 하는 것이죠

불변식을 이용하면 반복문의 정당성을 증명할 수 있습니다.

1. 반복문 집입시에 불변식이 성립함을 보인다.
2. 반복문 내용이 불변식을 깨뜨리지 않음을 보인다.
    - 반복문 내용이 시작할 때 불변식이 성립했다면 끝날 때도 항상 성립한다.
3. 반복문 종료시에 불변식이 성립하면 항상 불변식이 성립되됨을 보일 수 있다.

예를 들어 while 문에서 실제 불변식이 성립함을 보여야 하는 위치는 다음과 같습니다.

```cpp
// (*) 불변식은 여기에서 성립해야 한다.
while (condition) {
    // 반복문 내용의 시작
    ....
    // 반복문 내용의 끝
    // (**) 불변식은 여기에서도 성립해야 한다.
}
```

## 이진 탐색과 반복문 불변식

```cpp
// 필수 조건: A는 오름차순으로 정렬되어 있다.
// 결과: A[i-1] < x <= A[i]인 i를 반환한다.
// 이때 A[-1] == 음의 무한대, A[n] == 양의 무한대라고 가정한다.
int binsearch(const vectorint>& A, int x) {
    int n = A.size();
    int lo = -1 ,hi = n;
    // 반복문 불변식 1: lo < hi
    // 반복문 불변식 2: A[lo] < x <= A[hi]
    // (*) 불변식은 여기서 성립해야 한다.
    while(lo + 1 < hi) {
        int mid = (lo + hi) / 2;
        if(A[mid] < x)
            lo = mid;
        else
            hi = mid;
        // (**) 불변식은 여기서도 성립해야 한다
    }
    return hi;
}
```

여기서는 이렇게 증명합니다.

`반복문 불변식`이 성립 > `알고리즘` 증명

### 반복문 불변식이 성립하는지 확인

그럼 반복문 불변식이 성립하는지 확인해보겠습니다.

1. 초기 조건
    - while문이 시작할 때 lo와 hi는 초기값 -1과 n으로 초기화된 상태
    - `n=0` 일때 
        - 불변식 1은 while문을 건너뛰기 때문에 항상 성립
        - 불변식 2는 A[-1] = 음의 무한대, A[n] = 양의 무한대로 가정하기 때문에 성립
2. 유지조건
    - 불변식 1 `(lo < hi)`
        - while문 내로 들어왔다는 말은 hi와 lo의 차이가 2 이상이라는 의미
        - mid는 항상 두 값의 사이에 위치
        - mid를 lo에 대입하건, hi에 대입하건 불변식 1은 항상 유지
    - 불변식 2 `(A[lo] < x <= A[hi])`
        - A[mid] < x 인 경우
            - 반복문을 시작할 때 `x <= A[hi]` 는 이미 알고 있었음
            - `A[mid] < x <= A[hi]` 이므로 lo에 mid를 대입해도 불변식 성립
        - x <= A[mid] 인 경우
            - 반복문을 시작할 때 `A[lo] < x` 는 이미 알고 있음
            - `A[lo] < x <= A[mid]` 이므로 hi에 mid를 대입해도 불변식 성립

그래서 반복문 불변식 1, 2는 항상 성립한다고 볼 수 있음

### 반복문 불변식이 성립한다고 가정할 경우

만약 반복문 불변식 1, 2가 모두 끝까지 성립했다고 가정하면 우리는 알고리즘을 증명할 수 있을 겁니다.

1. lo + 1 = hi
    - while문이 종료했으니 lo + 1 >= hi일 것입니다, 불변식에 의해 lo < hi 이므로 lo < hi <= lo + 1
    - lo + 1 == hi 일수밖에 없습니다.
2. A[lo] < x <= A[hi]
    - 애초에 불변식이 성립한다고 가정했으므로 이 또한 성립합니다.

결국 우리가 원하는 결과값 i는 A[i - 1] < x <= A[i] 인 i이므로 우리가 원하는 결과는 hi라는 사실을 알 수 있습니다.






